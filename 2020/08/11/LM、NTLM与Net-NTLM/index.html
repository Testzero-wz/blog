<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="T3stzer0">


    <meta name="subtitle" content="思考">




<title>LM？NTLM？Net NTLM？ | T3stzer0&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>

<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css">
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
			expand_toc()
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">LM？NTLM？Net NTLM？</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">T3stzer0</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 11, 2020&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/安全研究/">安全研究</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="1-本地密码认证"><a href="#1-本地密码认证" class="headerlink" title="1. 本地密码认证"></a>1. 本地密码认证</h2><p> windows并不保存明文密码，只保存密码的Hash。本地密码认证时，操作系统会使用用户输入的密码作为凭证去与系统中的密码进行验证 ，路径为<code>%SystemRoot%\system32\config\sam</code>。</p>
<pre><code>过程：winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)
</code></pre><p>在用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，待输入过后将密码交给lsass.exe，这个进程的内存中会存一份明文密码，将明文密码加密成NTLM Hash，对SAM数据库比较认证。 mimikatz就是通过抓去lsass.exe的内存获取本地的明文密码的。</p>
<h3 id="1-1-LM-Hash"><a href="#1-1-LM-Hash" class="headerlink" title="1.1 LM Hash"></a>1.1 LM Hash</h3><p>在Windows xp、visa、Server 03 等早期Window系统，使用的是LM Hash(LAN Manager Hash)，由于其使用了DES加密并且对固定的字符串<code>KGS!@#$％</code>进行加密，容易遭受攻击，目前已被弃用。</p>
<p><img src="/2020/08/11/LM、NTLM与Net-NTLM/LM-Hash.png" alt="LM Hash"></p>
<p>具体的LM Hash的计算算法如下</p>
<ol>
<li>将用户口令明文转换为大写，并转换为OEM编码 (ASCII等于其本身)；</li>
<li>口令补零或截断到14位，并且分作前后2个部分，各7字节 （口令大于14在win xp上默认不存储LM Hash，但是在NTLM认证时LM Hash是会按口令截断到14位计算）；</li>
<li>对7字节字符串的每7个比特后面添加1比特0，变成64比特的DES密钥；</li>
<li>将上面的2个Key，使用DES算法，分别加密固定字符串<code>KGS!@#$％</code>，得到2个8字节的密文；</li>
<li>2个8字节的密文连成1个16字节的密文，称为LM Hash。</li>
</ol>
<pre><code class="lang-C">LMHash1 = DES(DOSCHARSET(UPPERCASE(password)), &quot;KGS!@#$％&quot;)
LMHash2 = DES(DOSCHARSET(UPPERCASE(password)), &quot;KGS!@#$％&quot;)
LMHash = LMHash1 + LMHash2
</code></pre>
<p><em>注：Win server 2008开始禁用LM Hash</em></p>
<h3 id="1-2-NT-Hash（AKA-NTLM-Hash）"><a href="#1-2-NT-Hash（AKA-NTLM-Hash）" class="headerlink" title="1.2 NT Hash（AKA. NTLM Hash）"></a>1.2 NT Hash（AKA. NTLM Hash）</h3><p>目前Windows系统使用的是NT Hash，有些资料也称为NTLM Hash。</p>
<pre><code class="lang-C">NT Hash = MD4(UTF-16-LE(password)) 
NTLM Hash = LM Hash + NT Hash
</code></pre>
<p> mimikatz提取的hash为NTLM Hash = LM Hash + NT Hash</p>
<p>由于目前Windows系统已经禁用了LM Hash，所以一般获取到的LM Hash是一个空密码的Hash，对我们没有利用价值也没有影响。</p>
<h2 id="2-网络环境下的密码认证——Net-NTLM"><a href="#2-网络环境下的密码认证——Net-NTLM" class="headerlink" title="2. 网络环境下的密码认证——Net-NTLM"></a>2. 网络环境下的密码认证——Net-NTLM</h2><p>Net-NTLM (New Technology LAN Manager)是<code>telnet</code>一种验证身份方式 ，目的是为了避免使用明文的密码进行认证传输， 旨在为用户提供身份验证，完整性和机密性。 其包括三个版本NTLMv1, NTLMv2 , NTLM2 Session 。</p>
<p>Net-NTLM认证采用质询/应答（Challenge/Response）的消息交换模式，流程如下：</p>
<ol>
<li>客户端向服务器发送一个请求，请求中包含明文的登录用户名。服务器会提前存储登录用户名和对应的密码hash；</li>
<li>服务器接收到请求后，生成一个随机数(这个随机数被称为Challenge)，明文发送回客户端，然后使用存储的登录用户密码hash加密Challenge，获得Challenge1；</li>
<li>客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，获得Challenge2(这个结果被称为response)，将response发送给服务器；</li>
<li>服务器接收客户端加密后的response，比较Challenge1和Challenge2，如果相同，验证成功。</li>
</ol>
<h3 id="2-1-Net-NTLMv1"><a href="#2-1-Net-NTLMv1" class="headerlink" title="2.1 Net-NTLMv1"></a>2.1 Net-NTLMv1</h3><pre><code class="lang-python">C = 8-byte server challenge, random
K1 , K2 , K3 = NTLM-Hash + &quot;\x00&quot;*5    # 21 Bytes
K1 = K1 + &quot;\x00&quot;
K2 = K2 + &quot;\x00&quot;
K3 = K3 + &quot;\x00&quot;
response = DES(K1,C) + DES(K2,C) + DES(K3,C)    # 24 Bytes
</code></pre>
<h3 id="2-1-Net-NTLMv2"><a href="#2-1-Net-NTLMv2" class="headerlink" title="2.1 Net-NTLMv2"></a>2.1 Net-NTLMv2</h3><p>Net-NTLMv2是Net-NTLMv1的增强版，询问流程相同，其不同之处在于：</p>
<ul>
<li>NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。</li>
<li>NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5</li>
</ul>
<pre><code class="lang-python">SC = 8-byte server challenge, random
CC = 8-byte client challenge, random
Blob = (Blob_signature, Timestamp, ClientNonce, Domain name, etc)
v2-Hash = HMAC-MD5(NT-Hash, to_hex_str(user_name+domain name))  # NT-Hash as key
LMv2 = HMAC-MD5(v2-Hash, SC+CC)    # v2-Hash as key
NTv2 = HMAC-MD5(v2-Hash, SC+Blob)    # v2-Hash as key
response1 = LMv2 + CC  
response2 = NTv2 + Blob     
# HMAC_MD5 is a alia of NTv2 in hashcat
# so we can define response2 as blow:
# response2 = HMAC_MD5 + Blob
</code></pre>
<p>其中<code>LMv2</code>在实际抓包中均为全<code>0</code>，Blob的结构如图：</p>
<p><img src="/2020/08/11/LM、NTLM与Net-NTLM/image-20200811205026735.png" alt="LM Hash"></p>
<p>Hashcat接收的Net-NTLM v2 Hash结构如下：</p>
<pre><code>username::domain:challenge:HMAC-MD5:blob
</code></pre><p>其中<code>HMAC-MD5</code>就是上面的<code>NTv2 = HMAC-MD5(v2-Hash, SC+Blob)</code>，也是抓包得到的数据包中的<code>NTProofStr</code>：</p>
<p><img src="/2020/08/11/LM、NTLM与Net-NTLM/NTProofStr.png" alt="NTProofStr.png"></p>
<h2 id="3-再来说说Pass-The-Hash攻击"><a href="#3-再来说说Pass-The-Hash攻击" class="headerlink" title="3. 再来说说Pass The Hash攻击"></a>3. 再来说说Pass The Hash攻击</h2><p>可以看到无论是本地密码认证还是网络环境下的密码认证，<strong>基本的凭证都是NTLM Hash，这也是Pth攻击能够成功的原因。</strong></p>
<p>我们使用mimikatz、gethashs.exe等工具获取到本地的NT Hash之后，就可以尝试进行远程登录了:</p>
<ol>
<li><p>可以碰撞相同密码的远程主机，再在远程主机上继续dumphash，获得更多账户的hash，鸡生蛋蛋又生鸡，然后在战利品里面寻找具有域管理员登陆过的机器；</p>
</li>
<li><p>利用当前账号的权限进行远程操作，扩大战果。如powershell、psexec、wmic、schtasks、at等等。</p>
</li>
</ol>
<p><strong>需要注意的是，SMB协议可以通过NTLM协议来完成认证，也可以通过Kerberos协议完成。</strong></p>
<p>Kerberos协议比较复杂，可以再开一篇文章在单独谈谈，目前我们只需要知道这两种协议都可以利用NTLM Hash来进行认证SMB服务即可。</p>
<p>当然， Kerberos已经是域环境下的默认安全认证协议了，当客户端提供Server的SPN（service principal name）访问时，会使用 Kerberos协议进行认证；而以IP地址访问服务端时，将使用NTLM协议进行身份认证。</p>
<pre><code class="lang-shell"># Kerberos
psexec domain.com/administrator@domain.com -hash &lt;NTLM Hash&gt; -c &lt;Command&gt;
# NTLM
psexec administrator@10.200.1.1 -hash &lt;NTLM Hash&gt; -c &lt;Command&gt;
</code></pre>
<p><strong>此时无论那种方式，最根本的凭证都是NTLM Hash，即Pass The Hash攻击仍然是奏效的。</strong></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p> <a href="https://payloads.online/archivers/2018-11-30/1" target="_blank" rel="noopener">https://payloads.online/archivers/2018-11-30/1</a> </p>
<p> [<a href="http://d1iv3.me/2018/12/08/LM-Hash%E3%80%81NTLM-Hash%E3%80%81Net-NTLMv1%E3%80%81Net-NTLMv2%E8%AF%A6%E8%A7%A3http://d1iv3.me/2018/12/08/LM-Hash、NTLM-Hash、Net-NTLMv1、Net-NTLMv2详解" target="_blank" rel="noopener">http://d1iv3.me/2018/12/08/LM-Hash%E3%80%81NTLM-Hash%E3%80%81Net-NTLMv1%E3%80%81Net-NTLMv2%E8%AF%A6%E8%A7%A3http://d1iv3.me/2018/12/08/LM-Hash、NTLM-Hash、Net-NTLMv1、Net-NTLMv2详解</a>) </p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>T3stzer0</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://www.testzero-wz.com/2020/08/11/LM、NTLM与Net-NTLM/">https://www.testzero-wz.com/2020/08/11/LM、NTLM与Net-NTLM/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/域渗透/"># 域渗透</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/22/Cobalt-Strike-Stager&Stage-Shellcode-深度解析/">Cobalt Strike Stager & Stage Shellcode 深度解析</a>
            
            
            <a class="next" rel="next" href="/2020/03/01/Psexec溯源/">如何通过Windows日志溯源Psexec</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- 
<footer id="footer" class="footer">
    <div class="copyright">
        <span>© T3stzer0 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

-->
<script src="/js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

    </div>
</body>
</html>
