<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="T3stzer0">


    <meta name="subtitle" content="思考">




<title>用C实现磁盘分析 | T3stzer0&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>

<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css">
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
			expand_toc()
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">用C实现磁盘分析</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">T3stzer0</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 16, 2017&nbsp;&nbsp;17:06:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/安全研究/">安全研究</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><img src="/2017/10/16/用C实现磁盘分析/20171010010507711.jpg" alt=""></p>
<blockquote>
<p>由于实验需要写一个分区表的分析程序，时间比较多就写了个适用于GPT和 MBR分区的通用程序</p>
</blockquote>
<a id="more"></a>
<p>没啥特别的亮点，主要还是可以通用地分析磁盘分区以及适用两种磁盘格式<br>本程序是字符界面，之前的是图形化界面，规划得有点丑，就不献丑了<br>自带分析、提取数据函数，若想继续分析其他也可在此基础上添加。在此只演示GPT下的FAT32分区分析<br><strong>注：需管理员权限运行，否则无法得到分区信息</strong></p>
<h3 id="分区-驱动器Drive类"><a href="#分区-驱动器Drive类" class="headerlink" title="分区/驱动器Drive类"></a>分区/驱动器Drive类</h3><pre><code class="lang-C">#pragma once
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;windows.h&gt;
using namespace std;
enum DriveType {
    NTFS, FAT32, GPT, UNKNOWN
};
class Drive {
public:
//通用属性

    DriveType type;
    int cluster;        //单位：扇区
    int sector;
    string label;        //卷标
    bool active;

    //Bytes
    long long offset;
    long long size;
    TCHAR msg[512];
//FAT32属性
    int reversedSector;
    int FATSector;

    //Bytes
    long long rootOffset;
    long long FATOffest;
//NTFS属性
    //待补充
    Drive(void) {
        active = false;
        memset(msg, -1, sizeof(msg));
    }
    ~Drive(void) {
    }
};
</code></pre>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><pre><code class="lang-C">#include &lt;stdio.h&gt;
#include&lt;windows.h&gt;
#include&lt;String&gt;
#include&lt;Vector&gt;
#include&quot;Drive.h&quot;

using namespace std;

#define NULL_16 (unsigned char *)&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
#define NULL_8  (unsigned char *)&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;
#define NULL_4 (unsigned char *)&quot;\x00\x00\x00\x00&quot;
#define NULL_2 (unsigned char *)&quot;\x00\x00&quot;


//读取磁盘在此修改
#define __READ &quot;\\\\.\\PHYSICALDRIVE0&quot;

#define EFI_FLAG (unsigned char *)&quot;EFI PART&quot;
#define NTFS_SYMBOL (unsigned char *)&quot;NTFS    &quot;
#define FAT32_SYMBOL (unsigned char *)&quot;MSDOS5.0&quot;

#define PARTITION_FLAG_LEN 8
#define OFFSET_DPT 446
#define SECTOR_LEN  512

long LODWORD(long long a);
long HIDWORD(long long a);
double ConvertToGB(long long size);
double ConvertToMB(long long size);
double ConvertToKB(long long size);
void ComfortableDataExpress(long long a,TCHAR * str);
double ComfortableData(long long a);
unsigned long long HexStringToLong(unsigned char * a,int len);

void TranslateData(unsigned char * a,int len, unsigned char * b,bool Remove_zero=0);

void Analysis_GPT(long long offset ,int show_analysis=0);
DriveType Analysis_Partition_Type(unsigned char *a ,int show_analysis=0);
void Analysis_DPT(unsigned char *a ,int show_analysis=0,bool extendFlag=0,long long posOffset=0);
DWORD ReadDisk(unsigned char* &amp;out,long start,long High,DWORD size,int pos=0);
bool Check(unsigned char * a,unsigned char *  str,int len=4);

static vector&lt;Drive&gt;DriveList;
static bool GPT_FLAG=0,MBR_FLAG=0,exFlag=1;;    //磁盘类型
static long long MainExtenedOffset=0;


int main()
{
    char buff[512];
    unsigned char* a;
    ReadDisk(a,NULL,NULL,512);
    printf(&quot;\n主分区DPT分析：\n&quot;);
    Analysis_DPT(&amp;a[OFFSET_DPT],1,0,NULL);
    printf(&quot;分区个数:%d\n&quot;,DriveList.size());
    printf(&quot;FAT32磁盘信息如下：\n&quot;);
    printf(&quot;    -------------------------------------------\n&quot;);
    for(int i=0;i&lt;DriveList.size();i++)
        {
            if(DriveList[i].type==FAT32)
            {
                printf(&quot;    分区序号：%d\n&quot;,i);
                ComfortableDataExpress(DriveList[i].size,buff);
                printf(&quot;    分区大小: %s  \n&quot;,buff );
                printf(&quot;    分区偏移:%I64d 字节\n&quot;,DriveList[i].offset);
                printf(&quot;    簇:%d 个扇区\n&quot;,DriveList[i].cluster);
                printf(&quot;    保留扇区:%d 个\n&quot;,DriveList[i].reversedSector);
                printf(&quot;    FAT表偏移:%I64d 字节\n&quot;,DriveList[i].FATOffest);
                printf(&quot;    FAT表扇区:%d 个\n&quot;,DriveList[i].FATSector);
                printf(&quot;    根目录偏移:%I64d 字节\n&quot;,DriveList[i].rootOffset);
                printf(&quot;    -------------------------------------------\n&quot;);

            }
        }
    return 0;
}



/*------------------------------------------------------------------------------------------------*/
//进制转换
double ConvertToGB(long long size)
 {
     return size/1024.0/1024.0/1024.0;
 }
 double ConvertToMB(long long size)
 {
     return size/1024.0/1024.0;
 }
 double ConvertToKB(long long size)
 {
     return size/1024.0;
 }

void ComfortableDataExpress(long long a,TCHAR * str)
{
    if(ConvertToGB(a)&gt;=1)sprintf(str,TEXT(&quot;%.2lf GB&quot;),ConvertToGB(a));
    else if(ConvertToMB(a)&gt;=1)sprintf(str,TEXT(&quot;%.2lf MB&quot;),ConvertToMB(a));
    else sprintf(str,TEXT(&quot;%.2lf KB&quot;),ConvertToKB(a));
}

double ComfortableData(long long a)
{
    if(ConvertToGB(a)&gt;=1)return ConvertToGB(a);
    else if(ConvertToMB(a)&gt;=1)return ConvertToMB(a);
    else return ConvertToKB(a);
}
long LODWORD(long long a)
{
    return (DWORD)a;
}
long HIDWORD(long long a)
{
    return (a&gt;&gt;32);
}


/*------------------------------------------------------------------------------------------------*/
//读取硬盘

DWORD ReadDisk(unsigned char* &amp;out,long start,long High,DWORD size,int pos)
{
    /*OVERLAPPED over = { 0 };
    over.Offset = start;  */

    HANDLE handle = CreateFile(
        TEXT(__READ),
        GENERIC_READ,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        0,
        OPEN_EXISTING,
        0,
        0);
    if (handle == INVALID_HANDLE_VALUE)return 0;
    unsigned char* buffer = new unsigned char[size + 1];
    SetFilePointer(handle, start, &amp;High, pos);
    DWORD readsize;
    if (ReadFile(handle, buffer, size, &amp;readsize, NULL) == 0)
    {
        CloseHandle(handle);
        return 0;
    }
    buffer[size] = 0;
    out = buffer;


    return size;
}
/*------------------------------------------------------------------------------------------------*/



/*------------------------------------------------------------------------------------------------*/
//判断字符

 bool Check(unsigned char * a,unsigned char * str,int len)
 {
     for(int i=0;i&lt;len;i++)
     {
         if(a[i]!=str[i])return false;
     }
     return true;
 }

/*------------------------------------------------------------------------------------------------*/


/*------------------------------------------------------------------------------------------------*/
//十六进制字符转十进制数字
 unsigned long long HexStringToLong(unsigned char * a,int len)
 {
     unsigned long long num=0,t=0;
     for(int i =0;i&lt;len;i++)
     {
         t=a[i];
         for(int j=i;j&gt;0;j--){
             t*=256;
         }
         num+=t;
     }
     return num;
 }

//获取字符信息
 void TranslateData(unsigned char * a,int len, unsigned char * b,bool Remove_zero)
   {
         int zero_num=0;
         int char_num=0;
         if (len){
             for (int i = 0; i &lt; len; i++){
                 if (Remove_zero)
                 {
                     if(a[i]==0)
                     {zero_num++;
                     continue;
                     }
                 }
                 char_num++;
                 b[i-zero_num]=a[i];
             }
         }
         b[char_num]=0;
         sprintf((char *)b,&quot;%s&quot;,b);
  }

 /*------------------------------------------------------------------------------------------------*/



/*------------------------------------------------------------------------------------------------*/
//分析DPT

 void Analysis_DPT(unsigned char *a ,int show_analysis,bool extenedFlag,long long posOffset)
 {
      TCHAR buff[512];
      unsigned char * BUFFER;
      long long offset=0;
      unsigned char * partition_sector;
      for (int i=0;i&lt;4;i++)
      {
          if(Check(&amp;a[i*16],NULL_16,16))break;
          else
          {
               if (show_analysis)
             {
                 printf(&quot; 活动分区标志: %02x |&quot;, a[0+i*16]);

                 printf(&quot; 分区类型标志: %02x |&quot;, a[4+i*16]);

                 printf(&quot; 偏移扇区: %I64d |&quot;, HexStringToLong(&amp;a[8+i*16],4));

                 ComfortableDataExpress(512*HexStringToLong(&amp;a[12+i*16],4),buff);
                 printf(&quot; 磁盘大小: %s  |\n&quot;,buff );
             }

              offset=512*HexStringToLong(&amp;a[8+i*16],4);
              if(Check(&amp;a[4+i*16],(unsigned char *)&quot;\x0f&quot;,1) || (i==1 &amp;&amp; extenedFlag))
              {

                  if(exFlag){
                     MainExtenedOffset = 512*HexStringToLong(&amp;a[8+i*16],4);
                     exFlag=0;
                  }
                  if(extenedFlag)offset+=MainExtenedOffset;

                  printf(&quot; 偏移扇区: %I64d |\n&quot;, HexStringToLong(&amp;a[8+i*16],4));

                  ReadDisk(partition_sector,LODWORD(offset),HIDWORD(offset),SECTOR_LEN);
                  Analysis_DPT(&amp;partition_sector[OFFSET_DPT],1,1,offset);
                  return ;
              }


              if(extenedFlag)offset+=posOffset;
              ReadDisk(partition_sector,LODWORD(offset),HIDWORD(offset),SECTOR_LEN);
              //ShowData(partition_sector,512);
              if(Analysis_Partition_Type(partition_sector)!=GPT)
              {
                  printf(&quot;\n检测到该磁盘为MBR磁盘!\n\n&quot;);
                  Drive drive;
                  //活动分区标志
                  if(a[0+i*16]==0x80)drive.active=true;
                  //盘位移
                  if(!extenedFlag)
                  offset=512*HexStringToLong(&amp;a[8+i*16],4);//计算逻辑分区的位移
                  drive.offset=offset;//存入位移
                  drive.size=512*HexStringToLong(&amp;a[12+i*16],4);//盘大小

                  //开始跳转至盘分析

                  ReadDisk(BUFFER,LODWORD(offset),HIDWORD(offset),1*SECTOR_LEN);
                  drive.type = Analysis_Partition_Type(BUFFER);
                  switch(drive.type)
                  {
                  case NTFS:
                      break;
                  case FAT32:
                     drive.cluster = HexStringToLong(&amp;BUFFER[0x0d],1);
                     drive.reversedSector=HexStringToLong(&amp;BUFFER[0x0e],2);
                     drive.FATOffest = drive.reversedSector * SECTOR_LEN;
                     drive.FATSector = HexStringToLong(&amp;BUFFER[0x24],4);
                     drive.rootOffset = drive.FATOffest + SECTOR_LEN * drive.FATSector *2;
                     break;
                  case UNKNOWN:
                      break;
                  }
                  DriveList.push_back(drive);
              }

              else
              {
                  printf(&quot;\n检测到该磁盘为GPT磁盘!\n\n&quot;);
                  Analysis_GPT(offset,1);
              }
          }
      }
  }


 /*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/


 DriveType Analysis_Partition_Type(unsigned char *a ,int show_analysis)
 {

           if(Check(a,EFI_FLAG,PARTITION_FLAG_LEN))
           {
               GPT_FLAG=1;
               if(show_analysis)printf(&quot; 磁盘为GPT磁盘!\n&quot;);
               return GPT;
           }
           else if(Check(&amp;a[3],NTFS_SYMBOL,PARTITION_FLAG_LEN))
           {
               if(show_analysis)printf(&quot;分区格式：%-10s|&quot;,&quot;NTFS&quot;);
               return NTFS;
           }
           else if(Check(&amp;a[3],FAT32_SYMBOL,PARTITION_FLAG_LEN))
           {
               if(show_analysis)printf(&quot;分区格式：%-10s|&quot;,&quot;FAT32&quot;);
               return FAT32;
           }
           else
           {
               if(show_analysis)printf(&quot;分区格式：%-10s|&quot;,&quot;UNKNOWN&quot;);
               return UNKNOWN;
           }
       }

/*------------------------------------------------------------------------------------------------*/




/*------------------------------------------------------------------------------------------------*/
 //解析GPT头

 void Analysis_GPT(long  long offset,int show_analysis)
 {

     TCHAR buff[512];
     unsigned char * GPT_PT;
     unsigned char * BUFFER;
     ReadDisk(GPT_PT,LODWORD(offset),HIDWORD(offset),32*SECTOR_LEN);
     long long GPT_Offset =  HexStringToLong(&amp;GPT_PT[0x48],8)*512;
     long long Offset=0;
     ReadDisk(GPT_PT,LODWORD(GPT_Offset),HIDWORD(GPT_Offset),32*SECTOR_LEN);

     for(int i=0;i&lt;128;i++)
     {
         if(Check(&amp;GPT_PT[i*128],NULL_16,16))break;
         Drive drive;
         //初始化GPT磁盘的分区属性

         //分区大小
         drive.size = 512*(HexStringToLong(&amp;GPT_PT[i*128+0x28],8)-HexStringToLong(&amp;GPT_PT[i*128+0x20],8) );
         //GPT头自带72字节的分区信息
         TranslateData(&amp;GPT_PT[i*128+0x38],72,(unsigned char *)drive.msg,true);
         //分区偏移
         Offset=512*(HexStringToLong(&amp;GPT_PT[i*128+0x20],8));
         drive.offset = Offset;
         ReadDisk(BUFFER,LODWORD(Offset),HIDWORD(Offset),1*SECTOR_LEN);
         drive.type = Analysis_Partition_Type(BUFFER);
         switch(drive.type)
         {
         case NTFS:
             break;
         case FAT32:

             drive.cluster = HexStringToLong(&amp;BUFFER[0x0d],1);
             drive.reversedSector=HexStringToLong(&amp;BUFFER[0x0e],2);
             drive.FATOffest = drive.reversedSector * SECTOR_LEN;
             drive.FATSector = HexStringToLong(&amp;BUFFER[0x24],4);
             drive.rootOffset = drive.FATOffest + SECTOR_LEN * drive.FATSector *2;
             break;
         case UNKNOWN:
             break;

         }

         DriveList.push_back(drive);

         if(show_analysis)
             {

                 ComfortableDataExpress(512*(HexStringToLong(&amp;GPT_PT[i*128+0x28],8)-HexStringToLong(&amp;GPT_PT[i*128+0x20],8) ),buff );
                 printf(&quot; 磁盘大小: %-10s  |&quot;,buff );
                 TranslateData(&amp;GPT_PT[i*128+0x38],72,(unsigned char *)buff,true);
                 Offset=512*(HexStringToLong(&amp;GPT_PT[i*128+0x20],8));
                 ReadDisk(BUFFER,LODWORD(Offset),HIDWORD(Offset),1*SECTOR_LEN);
                 Analysis_Partition_Type(BUFFER,1);
                 printf(&quot; GPT磁盘分区信息: %-30s |\n&quot;,buff);

             }
     }
     printf(&quot;\n&quot;);
 }

 /*------------------------------------------------------------------------------------------------*/
</code></pre>
<p>输出结果:</p>
<pre><code class="lang-bash">主分区DPT分析：
 活动分区标志: 00 | 分区类型标志: ee | 偏移扇区: 1 | 磁盘大小: 465.76 GB  |

检测到该磁盘为GPT磁盘!

 磁盘大小: 500.00 MB   |分区格式：FAT32     | GPT磁盘分区信息: EFI system partition           |
 磁盘大小: 40.00 MB    |分区格式：FAT32     | GPT磁盘分区信息: Basic data partition           |
 磁盘大小: 128.00 MB   |分区格式：UNKNOWN   | GPT磁盘分区信息: Microsoft reserved partition   |
 磁盘大小: 750.00 MB   |分区格式：NTFS      | GPT磁盘分区信息: Basic data partition           |
 磁盘大小: 188.96 GB   |分区格式：NTFS      | GPT磁盘分区信息: Basic data partition           |
 磁盘大小: 126.95 GB   |分区格式：NTFS      | GPT磁盘分区信息: Basic data partition           |
 磁盘大小: 69.71 GB    |分区格式：NTFS      | GPT磁盘分区信息: Basic data partition           |
 磁盘大小: 1023.50 KB  |分区格式：NTFS      | GPT磁盘分区信息:                                |
 磁盘大小: 40.00 GB    |分区格式：UNKNOWN   | GPT磁盘分区信息: Basic data partition           |
 磁盘大小: 300.00 MB   |分区格式：UNKNOWN   | GPT磁盘分区信息: Basic data partition           |
 磁盘大小: 8.46 GB     |分区格式：NTFS      | GPT磁盘分区信息: Microsoft recovery partition   |
 磁盘大小: 30.00 GB    |分区格式：UNKNOWN   | GPT磁盘分区信息:                                |

分区个数:12
FAT32磁盘信息如下：
    -------------------------------------------
    分区序号：0
    分区大小: 500.00 MB  
    分区偏移:1048576 字节
    簇:8 个扇区
    保留扇区:6206 个
    FAT表偏移:3177472 字节
    FAT表扇区:993 个
    根目录偏移:4194304 字节
    -------------------------------------------
    分区序号：1
    分区大小: 40.00 MB  
    分区偏移:525336576 字节
    簇:1 个扇区
    保留扇区:7038 个
    FAT表偏移:3603456 字节
    FAT表扇区:577 个
    根目录偏移:4194304 字节
    -------------------------------------------
</code></pre>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>T3stzer0</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://www.testzero-wz.com/2017/10/16/用C实现磁盘分析/">https://www.testzero-wz.com/2017/10/16/用C实现磁盘分析/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/二进制/"># 二进制</a>
                    
                        <a href="/tag/码代码/"># 码代码</a>
                    
                        <a href="/tag/实验/"># 实验</a>
                    
                        <a href="/tag/分区/"># 分区</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2017/11/01/用C实现32位PE文件分析/">用C实现32位PE文件分析</a>
            
            
            <a class="next" rel="next" href="/2017/10/09/世安杯-WriteUp/">世安杯-WriteUp</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- 
<footer id="footer" class="footer">
    <div class="copyright">
        <span>© T3stzer0 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

-->
<script src="/js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
